1
00:00:00,000 --> 00:00:23,519
Hello. Hello. Hello. Okay. Good evening, everyone. So, this is today's lecture. So, welcome to

1
00:00:00,000 --> 00:00:23,519
你好。你好。你好。好的。大家晚上好。所以，这是今天的讲座。那么，欢迎各位参加。

2
00:00:24,160 --> 00:00:32,719
thank you for your attendance. Today is the day before the holiday tomorrow. You're still here.

2
00:00:24,160 --> 00:00:32,719
感谢您的出席。今天是明天的假期的前一天。您还在这里。

3
00:00:32,719 --> 00:00:40,799
I'm very glad to see you. Okay. Last time, let's have a brief review about what we have learned

3
00:00:32,719 --> 00:00:40,799
我很高兴见到你。好的。上次，让我们简要回顾一下我们学到了什么

4
00:00:40,799 --> 00:00:52,879
last time about the digital signature. So, in digital signature in part one,

4
00:00:40,799 --> 00:00:52,879
上次关于数字签名。所以，在第一部分关于数字签名的部分，

5
00:00:52,880 --> 00:01:01,440
we finished part one about the RSA algorithm, how this one can be used to generate the RSA signature.

5
00:00:52,880 --> 00:01:01,440
我们完成了关于 RSA 算法的第一部分，介绍了如何使用 RSA 算法生成 RSA 签名。

6
00:01:02,400 --> 00:01:06,159
So, we have the signature generation and the signature verification.

6
00:01:02,400 --> 00:01:06,159
因此，我们有签名生成和签名验证。

7
00:01:10,240 --> 00:01:17,439
So, because we have the public key and the private key in the RSA algorithm,

7
00:01:10,240 --> 00:01:17,439
因此，由于我们在 RSA 算法中拥有公钥和私钥，

8
00:01:18,079 --> 00:01:26,079
and the private key can be used to generate the signature, and the public key can be used by the

8
00:01:18,079 --> 00:01:26,079
私钥可用于生成签名，公钥则可以被用于

9
00:01:26,079 --> 00:01:33,519
receiver to verify the correctness of your signature. So, you can see this process, you can see,

9
00:01:26,079 --> 00:01:33,519
接收者验证您签名的正确性。因此，您可以查看这个过程，您可以看得到。

10
00:01:35,039 --> 00:01:46,479
so we use the private key D to generate the signature S, and at the receiver side,

10
00:01:35,039 --> 00:01:46,479
因此，我们使用私钥 D 生成签名 S，在接收端，

11
00:01:47,040 --> 00:01:54,560
receiver will use the sender's public key to do the verification. So, in this way, we guarantee

11
00:01:47,040 --> 00:01:54,560
接收者将使用发送者的公钥进行验证。因此，我们以此保证

12
00:01:55,600 --> 00:02:06,880
the message is really from the sender like from Alice. So, we have this example to show how you can

12
00:01:55,600 --> 00:02:06,880
信息确实来自发送者，就像来自 Alice。因此，我们举这个例子来展示您如何

13
00:02:06,880 --> 00:02:15,040
generate the public key, private key, and how we can generate the signature, and also how can we

13
00:02:06,880 --> 00:02:15,040
生成公钥、私钥以及如何生成签名，以及我们如何生成签名

14
00:02:15,599 --> 00:02:24,000
apply the Chinese remainder theorem to quickly calculate a large number, but in generation,

14
00:02:15,599 --> 00:02:24,000
应用中国剩余定理快速计算大数，但在生成时，

15
00:02:26,239 --> 00:02:34,239
in the verification of the signature. So, step three is verification,

15
00:02:26,239 --> 00:02:34,239
在签名验证中。因此，第三步是验证，

16
00:02:35,919 --> 00:02:37,919
whether the signature is correct.

16
00:02:35,919 --> 00:02:37,919
是否签名正确。

17
00:02:38,399 --> 00:02:45,039
Now, we look at part two, and part two is another signature scheme. We call it to be the

17
00:02:38,399 --> 00:02:45,039
现在，我们来看第二部分，第二部分是另一种签名方案。我们称之为

18
00:02:45,039 --> 00:02:53,679
ALKMA digital signature. So, this one is based on the DLP problem. So, DLP problem is a discrete

18
00:02:45,039 --> 00:02:53,679
ALKMA 数字签名。因此，这个是基于 DLP 问题的。所以，DLP 问题是一个离散的

19
00:02:53,679 --> 00:02:59,919
logarithm problem. So, this one is also believed to be very hard to attack.

19
00:02:53,679 --> 00:02:59,919
对数问题。因此，这也被认为是非常难以攻击的。

20
00:02:59,919 --> 00:03:07,679
So, now, first, we look at the discrete logarithm problem, just like, you know,

20
00:02:59,919 --> 00:03:07,679
因此，现在首先，我们来看离散对数问题，就像，你知道的，

21
00:03:07,679 --> 00:03:18,239
abbreviation to be DLP problem. The input for this problem, we have the input. So, input is ZP star.

21
00:03:07,679 --> 00:03:18,239
缩写为 DLP 问题。该问题的输入我们有输入。所以，输入是 ZP 星。

22
00:03:18,239 --> 00:03:28,479
So, this is a set. This is a set of DLP problems. So, this is a set of DLP problems. So,

22
00:03:18,239 --> 00:03:28,479
这是一个集合。这是一个 DLP 问题的集合。所以，这是一个 DLP 问题的集合。所以，

23
00:03:29,359 --> 00:03:30,159
this is a set

23
00:03:29,359 --> 00:03:30,159
这是一个集合

24
00:03:42,879 --> 00:03:53,199
with all members from 1, 2, 3, till P must 1, and we assume P is a prime number.

24
00:03:42,879 --> 00:03:53,199
所有来自 1、2、3，直到 P 的成员都必须是 1，并且我们假设 P 是一个质数。

25
00:03:53,679 --> 00:04:02,560
So, this set contains all the numbers from 1 to P must 1. And we have another data G in this set.

25
00:03:53,679 --> 00:04:02,560
因此，这个集合包含从 1 到 P 的所有数字必须 1。并且在这个集合中我们还有另一个数据 G。

26
00:04:03,119 --> 00:04:13,280
So, G is a generator of ZP star. So, generator, or in some cases, we say it is a primitive root.

26
00:04:03,119 --> 00:04:13,280
所以，G 是 ZP 星的生成器。所以，生成器，或者在有些情况下，我们称其为原根。

27
00:04:23,360 --> 00:04:25,680
So, generator means

27
00:04:23,360 --> 00:04:25,680
因此，生成器意味着

28
00:04:35,439 --> 00:04:36,319
for any i

28
00:04:35,439 --> 00:04:36,319
对于任何 i

29
00:04:39,839 --> 00:04:41,839
in this ZP star,

29
00:04:39,839 --> 00:04:41,839
在這個 ZP 星

30
00:04:41,839 --> 00:04:49,119
so, G i mod P,

30
00:04:41,839 --> 00:04:49,119
因此，G i 模 P，

31
00:04:51,839 --> 00:04:52,719
G i mod P,

31
00:04:51,839 --> 00:04:52,719
G i 模 P，

32
00:04:56,319 --> 00:04:59,599
and these four members

32
00:04:56,319 --> 00:04:59,599
这四个成员

33
00:05:06,719 --> 00:05:09,919
in ZP star.

33
00:05:06,719 --> 00:05:09,919
在 ZP 星

34
00:05:12,719 --> 00:05:19,359
Okay, this is a good property for G to be a generator of ZP star. So, what's the meaning?

34
00:05:12,719 --> 00:05:19,359
好的，这是 G 成为 ZP 星生成器的良好性质。那么，这意味着什么呢？

35
00:05:20,159 --> 00:05:24,479
Well, in fact, we can look at this example. So, in this example,

35
00:05:20,159 --> 00:05:24,479
好吧，实际上我们可以看看这个例子。那么，在这个例子中，

36
00:05:27,839 --> 00:05:38,159
we have table. So, we have the B, the value B, right, can be from 1, 2, 3, 4, 5, 6.

36
00:05:27,839 --> 00:05:38,159
我们有表格。因此，我们有 B，B 的值，对吧，可以是 1、2、3、4、5、6。

37
00:05:39,040 --> 00:05:45,520
So, here P is a prime number to be 7. So, this ZP star

37
00:05:39,040 --> 00:05:45,520
因此，这里 P 是一个质数，取值为 7。因此，这个 ZP 星

38
00:05:47,920 --> 00:05:59,040
is this set X. So, X can take any value from 1 to 6. And we look at which B, B is the base,

38
00:05:47,920 --> 00:05:59,040
这是集合 X。因此，X 可以取从 1 到 6 的任何值。然后我们观察哪个 B，B 是基数，

39
00:05:59,040 --> 00:06:05,840
right, B is the base, just like previously the G. So, G i, we look at these two rows.

39
00:05:59,040 --> 00:06:05,840
正确，B 是基，就像之前 G 一样。所以，我们看这两行 G i。

40
00:06:06,479 --> 00:06:17,759
When B equals 3 and B equals 5. So, you can see G B i. So, in this example, it is B i

40
00:06:06,479 --> 00:06:17,759
当 B 等于 3 和 B 等于 5 时。因此，你可以看到 G B i。所以，在这个例子中，它是 B i

41
00:06:21,199 --> 00:06:21,839
mod P,

41
00:06:21,199 --> 00:06:21,839
模 P，

42
00:06:22,000 --> 00:06:31,919
P is 7. So, we look at BX mod 7, and the result can represent

42
00:06:22,000 --> 00:06:31,919
P 是 7。因此，我们查看 BX mod 7，结果可以表示

43
00:06:33,679 --> 00:06:46,399
all members in the set X. So, when we take the B to be the value to be 3, so we can see B1 mod 7

43
00:06:33,679 --> 00:06:46,399
所有集合 X 中的成员。因此，当我们取 B 的值为 3 时，我们可以看到 B1 mod 7

44
00:06:46,399 --> 00:06:59,599
is 3, right, because B equals 3. And B squared, that's 3 times 3 is 9, 9 mod 7, we have 2.

44
00:06:46,399 --> 00:06:59,599
是 3，对，因为 B 等于 3。B 的平方，即 3 乘以 3 是 9，9 对 7 取模，结果是 2。

45
00:07:01,199 --> 00:07:14,959
And B cubed, 2 times 3, that's 6. B to the fourth, that's 6 times 3, that's 18,

45
00:07:01,199 --> 00:07:14,959
B 的三次方，2 乘以 3，等于 6。B 的四次方，等于 6 乘以 3，等于 18，

46
00:07:15,919 --> 00:07:27,199
mod 7, we have 4. So, 4 times 3, that's 12, 12 mod 7, we have 5. 5 times 3, that's 15,

46
00:07:15,919 --> 00:07:27,199
模 7，我们有 4。所以，4 乘以 3，那是 12，12 模 7，我们有 5。5 乘以 3，那是 15，

47
00:07:27,759 --> 00:07:36,639
mod 7, we have 1. And all the results you can see, we can have all members 1, 2, 3, 4, 5, 6,

47
00:07:27,759 --> 00:07:36,639
模 7，我们有 1。所有你能看到的结果，我们可以有所有成员 1，2，3，4，5，6，

48
00:07:36,639 --> 00:07:47,919
all the members in the set X, right? And thus, we say B equals 3, these two are the generators.

48
00:07:36,639 --> 00:07:47,919
所有集合 X 中的成员，对吧？因此，我们说 B 等于 3，这两个是生成元。

49
00:07:47,920 --> 00:07:53,199
Generators.

49
00:07:47,920 --> 00:07:53,199
发生器。

50
00:07:59,759 --> 00:08:06,639
For B equals 3 or 5, so these two data can be the generators in this example. For P

50
00:07:59,759 --> 00:08:06,639
对于 B 等于 3 或 5，因此这两个数据可以作为本例中的生成器。对于 P

51
00:08:07,360 --> 00:08:20,959
equals 7. However, if B equals 2, and the result will be repeated with only

51
00:08:07,360 --> 00:08:20,959
等于 7。然而，如果 B 等于 2，结果将重复，只有

52
00:08:22,000 --> 00:08:33,519
2, 4, 1, and 2, 4, 1 repeated. So, when B equals 2, we cannot get all members in the set X. So,

52
00:08:22,000 --> 00:08:33,519
2，4，1，和 2，4，1 重复。因此，当 B 等于 2 时，我们无法得到集合 X 中的所有成员。所以，

53
00:08:33,519 --> 00:08:47,039
set X is ZP star, right? In other words, B cannot be 2 or 4 or 6 to be the generator.

53
00:08:33,519 --> 00:08:47,039
集合 X 是 ZP 星，对吧？换句话说，B 不能是 2 或 4 或 6 作为生成元。

54
00:08:47,759 --> 00:09:00,399
We need to guarantee when I take the value from 1 to 6, the result can list all members in the set

54
00:08:47,759 --> 00:09:00,399
我们需要保证当我从 1 取到 6 的值时，结果可以列出集合中的所有成员

55
00:09:00,399 --> 00:09:10,879
X. Is that clear? Okay, so this is the definition about the generator. So, in some cases,

55
00:09:00,399 --> 00:09:10,879
X. 这清楚吗？好的，那么这是关于生成器的定义。所以，在某些情况下，

56
00:09:10,879 --> 00:09:20,959
we call it to be the primitive root. And given that B is a number in the set ZP star,

56
00:09:10,879 --> 00:09:20,959
我们称之为原根。鉴于 B 是集合 ZP 星中的数，

57
00:09:21,920 --> 00:09:32,720
and this is create logarithm problem, we'll ask you to find a unique number A. So, this A is

57
00:09:21,920 --> 00:09:32,720
is 创建对数问题，我们将要求你找到一个唯一的数字 A。所以，这个 A 是

58
00:09:32,720 --> 00:09:44,879
smaller than the P, such that G to the A is congruent to B more P. Okay, we want to find

58
00:09:32,720 --> 00:09:44,879
小于 P，使得 G 到 A 的对应与 B 到 P 的对应相同。好吧，我们要找到

59
00:09:44,960 --> 00:09:57,840
this exponent number A such that G to the A more P equals B. So, we denote this value A as discrete

59
00:09:44,960 --> 00:09:57,840
这个指数数 A，使得 G 的 A 次方加 P 等于 B。因此，我们把这个值 A 表示为离散的。

60
00:09:57,840 --> 00:10:12,399
log of the number B for the base G more P. So, we have this GP the meaning. So, in fact, if we have

60
00:09:57,840 --> 00:10:12,399
日志中 B 对底数 G 的幂次为 P。因此，我们有了这个 GP 的含义。实际上，如果我们有

61
00:10:13,360 --> 00:10:24,639
for A, if we have A, G and P to calculate B, this is easy, right?

61
00:10:13,360 --> 00:10:24,639
对于 A，如果我们有 A、G 和 P 来计算 B，这很简单，对吧？

62
00:10:27,600 --> 00:10:40,240
With the value A, G, P to calculate B, it is easy. However, with the G, with G, this generator, P

62
00:10:27,600 --> 00:10:40,240
使用 A、G、P 的值来计算 B，很容易。然而，对于 G，对于这个生成器，P

63
00:10:41,200 --> 00:10:51,120
and B to calculate A, this is very difficult, very difficult.

63
00:10:41,200 --> 00:10:51,120
并且用 B 来计算 A，这非常困难，非常困难。

64
00:10:55,840 --> 00:11:07,759
So, currently, we do not have a convenient way to get A easily. So, this is actually an exponential

64
00:10:55,840 --> 00:11:07,759
因此，目前我们还没有一种方便的方法来轻易获得 A。所以，这实际上是一个指数

65
00:11:07,840 --> 00:11:15,439
problem where probably we need to try all possibilities. So, we have this assumption.

65
00:11:07,840 --> 00:11:15,439
问题可能需要尝试所有可能性。因此，我们有了这个假设。

66
00:11:15,439 --> 00:11:23,679
This assumption is called the DL assumption. So, this assumption says there is no efficient

66
00:11:15,439 --> 00:11:23,679
这个假设被称为 DL 假设。因此，这个假设表明不存在有效的

67
00:11:23,679 --> 00:11:33,200
algorithm in polynomial time. So, non-exponential time to solve DL problem. So, this is DL problem,

67
00:11:23,679 --> 00:11:33,200
多项式时间算法。因此，非指数时间解决DL问题。因此，这是一个DL问题。

68
00:11:33,200 --> 00:11:49,360
okay? Given G, P, B to get A, this is the DL problem. Well, today, it is still widely believed

68
00:11:33,200 --> 00:11:49,360
好的？给定 G、P、B 得到 A，这就是DL问题。嗯，今天，人们仍然普遍认为

69
00:11:49,360 --> 00:11:57,440
that this assumption holds. It is true, very difficult. So, difficulty is said is similar

69
00:11:49,360 --> 00:11:57,440
这个假设成立。确实，非常困难。因此，所说的困难是相似的。

70
00:11:58,080 --> 00:12:09,360
to the RSA algorithm. When you have a big N, you will find P times Q, this factorization.

70
00:11:58,080 --> 00:12:09,360
对于 RSA 算法。当你有一个大的 N 时，你会找到 P 乘以 Q，这个因式分解。

71
00:12:15,360 --> 00:12:22,560
The difficulty of factorization will be similar to this DL problem, similar difficulty.

71
00:12:15,360 --> 00:12:22,560
因式分解的难度将与这个DL问题相似，难度相当。

72
00:12:27,440 --> 00:12:41,040
Given that just like the P can be very large with a size like to be 1 or 24 bits, okay? A very large

72
00:12:27,440 --> 00:12:41,040
鉴于 P 可以非常大，大小类似于 1 或 24 位，好吗？非常大

73
00:12:41,040 --> 00:12:50,400
number. In that case, it is difficult for you to calculate the A given B.

73
00:12:41,040 --> 00:12:50,400
数字。在这种情况下，您很难根据 B 计算 A。

74
00:12:50,399 --> 00:13:06,240
So, here we have explained this table, right? Just we list the base B, and when B equals 1, 2, 3, 4, 5, 6,

74
00:12:50,399 --> 00:13:06,240
所以，我们已经解释了这个表格，对吧？我们只列出了基数 B，当 B 等于 1、2、3、4、5、6 时，

75
00:13:06,879 --> 00:13:17,199
and B, I, more P, what's the result in this table? And we can see only when B equals 3 or 5,

75
00:13:06,879 --> 00:13:17,199
并且 B、I、更多的 P，这个表格中的结果是什么？我们可以看到只有当 B 等于 3 或 5 时，

76
00:13:18,080 --> 00:13:26,800
we can get all possible result to make the result to equal the set ZP star.

76
00:13:18,080 --> 00:13:26,800
我们可以得到所有可能的结果，使结果等于集合 ZP 星。

77
00:13:29,680 --> 00:13:35,120
So, according to previous table, we look at how can we solve the DLP problem.

77
00:13:29,680 --> 00:13:35,120
因此，根据前表，我们来看如何解决DLP问题。

78
00:13:35,759 --> 00:13:54,240
As we know, if the base equals B or G equals 3. So, G equals 3, 3 squared plus 7 is 2.

78
00:13:35,759 --> 00:13:54,240
如我们所知，如果基数等于 B 或 G 等于 3。因此，G 等于 3，3 的平方加 7 等于 2。

79
00:13:54,240 --> 00:14:06,720
So, for this discrete log of 2, we want to get its exponent. So, exponent number should be 2 here.

79
00:13:54,240 --> 00:14:06,720
因此，对于 2 的这个离散对数，我们想要得到它的指数。所以，指数数应该是 2。

80
00:14:07,680 --> 00:14:23,279
So, the discrete log of 2 for the base 3, this is G mod 7, this is P. The exponent in this example

80
00:14:07,680 --> 00:14:23,279
所以，以 3 为底 2 的离散对数，这是 G 模 7，这是 P。在这个例子中的指数

81
00:14:23,279 --> 00:14:38,480
should be 2. Well, for this example, because 3 cubed plus 7, we have 6. And this discrete log of 6,

81
00:14:23,279 --> 00:14:38,480
应为 2。嗯，在这个例子中，因为 3 的三次方加 7，我们得到 6。这是 6 的离散对数，

82
00:14:41,839 --> 00:14:52,720
for the base 3 mod 7, the exponent should be 3. And similarly, this 5, we have the result to be

82
00:14:41,839 --> 00:14:52,720
对于底数 3 模 7，指数应该是 3。同样地，这个 5，我们得到的结果是

83
00:14:54,240 --> 00:15:06,720
5. So, how about this one? Well, if the base is 2 and the B is 4, if base is 2

83
00:14:54,240 --> 00:15:06,720
5. 那么，这个怎么样？嗯，如果基数是 2，B 是 4，如果基数是 2

84
00:15:08,799 --> 00:15:13,839
and the result is 4. So, in fact, we can find two cases.

84
00:15:08,799 --> 00:15:13,839
结果为 4。因此，实际上我们可以找到两种情况。

85
00:15:14,480 --> 00:15:25,360
This is case 1. This is case 2. And this shows that the exponent can be either 2 or 5. So, we do not

85
00:15:14,480 --> 00:15:25,360
这是案例 1。这是案例 2。这表明指数可以是 2 或 5。因此，我们不需要

86
00:15:25,360 --> 00:15:42,639
have a unique result. The result can be either 2 or 5. But, because the B, G to the G squared mod 7,

86
00:15:25,360 --> 00:15:42,639
具有独特的结果。结果可以是 2 或 5。但是，因为 B、G 到 G 平方模 7，

87
00:15:42,799 --> 00:15:48,000
is 4, and also G to the 5 mod 7, is also 4.

87
00:15:42,799 --> 00:15:48,000
是 4，并且 G 模 7 等于 5，也是 4。

88
00:15:51,759 --> 00:15:58,480
So, the reason is because G equals 2 is not a generator.

88
00:15:51,759 --> 00:15:58,480
因此，原因是 G 等于 2 不是一个生成元。

89
00:15:58,560 --> 00:16:14,240
The result will not be unique. So, this is not allowed. We must choose the

89
00:15:58,560 --> 00:16:14,240
结果不会唯一。因此，这是不允许的。我们必须选择

90
00:16:15,039 --> 00:16:23,360
the base G to be a generator, such that in this discrete log calculation, the result will be unique.

90
00:16:15,039 --> 00:16:23,360
基础 G 作为生成元，使得在此离散对数计算中，结果将是唯一的。

91
00:16:28,639 --> 00:16:39,600
Okay, based on the DLP problem, we look at how we can construct some of the public key and private

91
00:16:28,639 --> 00:16:39,600
好的，基于 DLP 问题，我们探讨如何构建一些公钥和私钥

92
00:16:39,600 --> 00:16:48,639
key. And now we look at for this DLP problem, some property for this problem. If P is small,

92
00:16:39,600 --> 00:16:48,639
关键。现在我们来看这个 DLP 问题的一些性质。如果 P 很小，

93
00:16:49,519 --> 00:16:57,279
discrete log can be found by exhaustive search. Now, we can try all possible of i.

93
00:16:49,519 --> 00:16:57,279
离散对数可以通过穷举搜索找到。现在，我们可以尝试所有可能的 i。

94
00:16:59,279 --> 00:17:04,559
So, i, we can exhaustive search i in this set,

94
00:16:59,279 --> 00:17:04,559
因此，我们可以在这个集合中穷举搜索 i

95
00:17:07,759 --> 00:17:12,559
JP star, right? From 1, 2, 3,

95
00:17:07,759 --> 00:17:12,559
日星，对吧？从 1、2、3，

96
00:17:12,559 --> 00:17:42,559
4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 52, 53, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54

96
00:17:12,559 --> 00:17:42,559
4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 52, 53, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54

97
00:17:42,559 --> 00:17:53,919
trial or possibilities to see which exponent to make the result equals the given p, okay?

97
00:17:42,559 --> 00:17:53,919
试验或寻找哪种指数可以使结果等于给定的 p，好吗？

98
00:17:58,159 --> 00:18:06,639
Well, we will make the p to be very large. So the size of prime p for which dl can be computed

98
00:17:58,159 --> 00:18:06,639
嗯，我们将使 p 变得非常大。因此，对于可以计算 dl 的素数 p 的大小

99
00:18:07,200 --> 00:18:13,759
is approximately the same size, the same as the size of integers that can be

99
00:18:07,200 --> 00:18:13,759
约等于相同大小，与整数的规模相同

100
00:18:13,759 --> 00:18:21,920
factored. So normally we will choose the p to be one or 24 bits. At this moment,

100
00:18:13,759 --> 00:18:21,920
因式分解。因此，我们通常会选择 p 为 1 或 24 位。在此时刻，

101
00:18:23,040 --> 00:18:34,560
this size is believed to be quite secure. For the deal problem, this is in fact an example

101
00:18:23,040 --> 00:18:34,560
这个尺寸被认为相当安全。对于交易问题，这实际上是一个例子

102
00:18:34,960 --> 00:18:45,759
one-way function. So one function means from g, p, and a to get,

102
00:18:34,960 --> 00:18:45,759
单射函数。所以一个函数意味着从 g、p 和 a 得到，

103
00:18:48,639 --> 00:18:53,039
or we say x, to get y. So this

103
00:18:48,639 --> 00:18:53,039
或者我们说 x，以得到 y。所以这个

104
00:18:54,000 --> 00:19:10,639
is, this means we can calculate the function g to the x mod p to get y. Finding fx, this is easy.

104
00:18:54,000 --> 00:19:10,639
这是，这意味着我们可以计算函数 g(x) mod p 得到 y。找到 fx，这很简单。

105
00:19:11,599 --> 00:19:19,839
However, given y, finding x, to certify this equation, it is hard. In the deal problem,

105
00:19:11,599 --> 00:19:19,839
然而，给定 y，寻找 x，以验证此方程，是困难的。在交易问题中，

106
00:19:19,839 --> 00:19:31,359
that means given g, p, y to find x, this is very difficult because you need to guarantee

106
00:19:19,839 --> 00:19:31,359
这意味着给定 g、p、y 来寻找 x，这非常困难，因为你需要保证

107
00:19:31,439 --> 00:19:49,519
p gx mod p equals y. So this is almost impossible, okay? If the p is very large, to get this x is

107
00:19:31,439 --> 00:19:49,519
p gx mod p 等于 y。所以这几乎是不可能的，好吗？如果 p 非常大，要得到这个 x 是

108
00:19:50,079 --> 00:20:00,319
almost impossible. So based on this good property, we have the l comma signature scheme.

108
00:19:50,079 --> 00:20:00,319
几乎不可能。因此，基于这一良好性质，我们得到了 l 逗号签名方案。

109
00:20:01,359 --> 00:20:08,240
So you can see different cryptography based on different mathematical problems. The RSA is based

109
00:20:01,359 --> 00:20:08,240
所以您可以看到基于不同数学问题的不同密码学。RSA 基于

110
00:20:08,240 --> 00:20:16,959
on the factorization of a big number, the difficulty. And this one is based on the difficulty of the deal

110
00:20:08,240 --> 00:20:16,959
关于大数分解的难度，以及这个基于交易难度的因素。

111
00:20:16,959 --> 00:20:26,319
problem. This scheme is based on the difficulty of computing discrete logarithm over the zp

111
00:20:16,959 --> 00:20:26,319
问题。该方案基于在 zp 上计算离散对数的难度

112
00:20:26,480 --> 00:20:35,679
over this set. So p is prime. In this signature scheme, we have the setup and the key generation

112
00:20:26,480 --> 00:20:35,679
在此集合上。因此 p 是质数。在此签名方案中，我们具有设置和密钥生成

113
00:20:36,240 --> 00:20:47,439
step. And suppose Alice is the one to use this scheme. Alice will choose large prime p.

113
00:20:36,240 --> 00:20:47,439
步骤。假设爱丽丝使用这个方案。爱丽丝将选择大素数 p。

114
00:20:48,160 --> 00:20:58,160
Well, so p minus one, p is an odd number. So p minus one is an even number, right? Even number.

114
00:20:48,160 --> 00:20:58,160
嗯，所以 p 减 1，p 是一个奇数。所以 p 减 1 是一个偶数，对吧？偶数。

115
00:20:58,160 --> 00:21:05,600
So seven, if p equals seven, p minus one is six. Six is an even number. So even number must have

115
00:20:58,160 --> 00:21:05,600
所以七，如果 p 等于七，p 减一等于六。六是一个偶数。所以偶数必须有

116
00:21:05,600 --> 00:21:15,440
some prime factor. And we will require p minus one has a large prime factor. So p minus one is

116
00:21:05,600 --> 00:21:15,440
某些质数因子。我们需要 p 减一有一个大的质数因子。所以 p 减一是

117
00:21:15,840 --> 00:21:21,120
has a large prime factor. So this is for the security purpose.

117
00:21:15,840 --> 00:21:21,120
具有一个大素数因子。因此这是出于安全目的。

118
00:21:26,880 --> 00:21:27,759
Security purpose.

118
00:21:26,880 --> 00:21:27,759
安全目的。

119
00:21:31,519 --> 00:21:44,559
Then for the given p, we are able to know which data is a primitive root

119
00:21:31,519 --> 00:21:44,559
然后对于给定的 p，我们能够知道哪些数据是原根

120
00:21:44,559 --> 00:21:49,839
or primitive element. So this is the meaning of generator.

120
00:21:44,559 --> 00:21:49,839
原始元素。因此，这就是发生器的含义。

121
00:21:53,039 --> 00:22:02,639
So we choose one data to be the generator to the prime number p, okay? So given the p is prime,

121
00:21:53,039 --> 00:22:02,639
因此我们选择一个数据作为素数 p 的生成器，好吗？所以给定的 p 是素数，

122
00:22:02,639 --> 00:22:09,519
the multiple number can be the generator. So we choose one. And then Alice will choose

122
00:22:02,639 --> 00:22:09,519
多个数可以作为生成器。所以我们选择一个。然后 Alice 将选择

123
00:22:10,079 --> 00:22:22,799
x, small x as her private key and calculate the gx small p to get y. The public key is p, g and y.

123
00:22:10,079 --> 00:22:22,799
x，小 x 作为她的私钥，计算 gx 小 p 得到 y。公钥是 p，g 和 y。

124
00:22:23,599 --> 00:22:33,039
The primary key for Alice is this x, right? From x to get y is easy.

124
00:22:23,599 --> 00:22:33,039
Alice 的主键是这个 x，对吧？从 x 得到 y 很容易。

125
00:22:33,039 --> 00:22:46,000
And then to sign a message, this is a big x. Alice needs to choose an integer k. So this k,

125
00:22:33,039 --> 00:22:46,000
然后要签名一个消息，这是一个大 X。Alice 需要选择一个整数 k。所以这个 k，

126
00:22:47,839 --> 00:22:55,920
we can say this k is a one-time random key.

126
00:22:47,839 --> 00:22:55,920
我们可以称这个 k 为一个一次性随机密钥。

127
00:23:03,039 --> 00:23:21,119
For one message x, we will choose one key, one different key, k. So this key k should be

127
00:23:03,039 --> 00:23:21,119
对于消息 x，我们将选择一个密钥，一个不同的密钥 k。因此，这个密钥 k 应该是

128
00:23:21,119 --> 00:23:28,879
smaller than or equal to p minus one. And also we need to guarantee that the gcd, k and p minus one

128
00:23:21,119 --> 00:23:28,879
小于或等于 p 减一。同时，我们还需要保证最大公约数 k 和 p 减一

129
00:23:28,880 --> 00:23:36,560
is one, the relative prime, because we need to calculate this module inverse. So this will

129
00:23:28,880 --> 00:23:36,560
这是一个相对质数，因为我们需要计算这个模逆元。所以这将

130
00:23:36,560 --> 00:23:57,600
guarantee that we have the k minus one mod p minus one. So there are relatively primes

130
00:23:36,560 --> 00:23:57,600
保证我们有 k 减一模 p 减一。因此，存在互质的

131
00:23:57,599 --> 00:24:04,319
and this means we are able to calculate the module inverse of k mod p minus one.

131
00:23:57,599 --> 00:24:04,319
这意味着我们可以计算 k mod p 减一的模逆。

132
00:24:06,000 --> 00:24:17,439
And then Alice will calculate gk mod p to be r. Well, in this way, r will be the signature.

132
00:24:06,000 --> 00:24:17,439
remainder: 然后爱丽丝将计算 gk mod p 得到 r。嗯，这样，r 将成为签名。

133
00:24:18,080 --> 00:24:28,480
So rs will be the signature. So you can see the k is a one-time random key, right? But gk mod p

133
00:24:18,080 --> 00:24:28,480
所以 rs 将是签名。所以你可以看到 k 是一个一次性的随机密钥，对吧？但是 gk mod p

134
00:24:29,200 --> 00:24:43,200
equals r, the r will be no. However, with r, you cannot know the k. So this key k will not be

134
00:24:29,200 --> 00:24:43,200
等于 r，则 r 将不存在。然而，有了 r，你无法知道 k。因此，这个密钥 k 将不会

135
00:24:44,160 --> 00:24:54,160
disclosed. The receiver will only get r and s. Now we look at what's s. So s equals

135
00:24:44,160 --> 00:24:54,160
披露。接收者只能获得 r 和 s。现在我们来看 s 是什么。所以 s 等于

136
00:24:55,920 --> 00:25:03,680
module inverse of k minus one. Here we mod p minus one. So we have k minus one times,

136
00:24:55,920 --> 00:25:03,680
模逆元 k 减一。这里我们对 p 减一取模，所以我们有 k 减一乘以，

137
00:25:03,680 --> 00:25:17,840
this is the message x minus the private key of Alice times r. So r from here, and Alice has a

137
00:25:03,680 --> 00:25:17,840
这是消息 x 减去 Alice 的私钥乘以 r。所以从这里开始是 r，Alice 有

138
00:25:17,840 --> 00:25:27,920
private key, right? So of course Alice is able to calculate the k minus one times the message

138
00:25:17,840 --> 00:25:27,920
私钥，对吧？所以当然 Alice 能够计算出 k 减 1 倍的报文

139
00:25:27,920 --> 00:25:38,240
minus her private key times r and then mod p minus one to be another signature s.

139
00:25:27,920 --> 00:25:38,240
减去她的私钥乘以 r 然后对 p 减一取模得到另一个签名 s。

140
00:25:40,720 --> 00:25:54,400
The send message is the message end with the r and s. r and s will be sent along with x to the

140
00:25:40,720 --> 00:25:54,400
发送消息是以 r 和 s 结尾的消息。r 和 s 将与 x 一起发送。

141
00:25:54,400 --> 00:26:06,960
receiver like Bob. When Bob received this message, Bob will do the signature verification.

141
00:25:54,400 --> 00:26:06,960
接收者如鲍勃。当鲍勃收到这条消息时，鲍勃将进行签名验证。

142
00:26:07,759 --> 00:26:20,400
To verify the message, Bob will do the comparison of g to the x and y to the r times r to the s.

142
00:26:07,759 --> 00:26:20,400
为了验证信息，鲍勃将对 g 与 x 以及 y 与 r 乘以 r 的 s 次方进行比较。

143
00:26:25,120 --> 00:26:26,480
So y is the public key.

143
00:26:25,120 --> 00:26:26,480
所以 y 是公钥。

144
00:26:29,920 --> 00:26:43,280
So these are the public key, public key now g, p, and y to be known by receiver by Bob.

144
00:26:29,920 --> 00:26:43,280
所以这些是公钥，公钥现在为 g、p 和 y，由接收者鲍勃知晓。

145
00:26:44,240 --> 00:26:57,039
g, p, y is a public key to be known by anyone else. Okay, we want to know why this equation is

145
00:26:44,240 --> 00:26:57,039
g, p, y 是任何其他人都要知道的公钥。好吧，我们想知道为什么这个等式是

146
00:26:57,039 --> 00:27:10,079
true. The gx equals yr times rs. That means your signature is correct. So of course you can see

146
00:26:57,039 --> 00:27:10,079
真。gx 等于 yr 乘以 rs。这意味着您的签名是正确的。所以当然您可以看到

147
00:27:10,079 --> 00:27:13,359
the receiver will use Alice, the public key,

147
00:27:10,079 --> 00:27:13,359
接收者将使用 Alice 的公钥，

148
00:27:20,240 --> 00:27:28,559
in the verification, right? y is the public key of Alice. So this public key will be sent to Bob.

148
00:27:20,240 --> 00:27:28,559
在验证中，对吧？y 是 Alice 的公钥。所以这个公钥将被发送给 Bob。

149
00:27:29,200 --> 00:27:38,480
So Bob will use Alice's public key r in the verification. So in this way Bob will guarantee

149
00:27:29,200 --> 00:27:38,480
所以 Bob 将使用 Alice 的公钥 r 进行验证。因此，通过这种方式，Bob 将保证

150
00:27:38,480 --> 00:27:47,679
the message is really from Alice because I'm using your public key y in this verification. So small r,

150
00:27:38,480 --> 00:27:47,679
信息确实来自 Alice，因为我使用您的公钥 y 进行验证。所以小的 r，

151
00:27:48,000 --> 00:27:54,320
is really from Alice because I'm using your public key y in this verification.

151
00:27:48,000 --> 00:27:54,320
实际上是因为我在这次验证中使用了你的公钥 y，所以确实是来自 Alice。

152
00:27:55,120 --> 00:28:04,400
So small r, small s are the signed signature you sent to me. I use your public key y in the

152
00:27:55,120 --> 00:28:04,400
所以小的 r，小的 s 是您发送给我的带符号签名。我使用您的公钥 y 在

153
00:28:04,400 --> 00:28:12,880
verification. So g is the public key and also I apply the message in the verification, right?

153
00:28:04,400 --> 00:28:12,880
验证。所以 g 是公钥，并且我在验证中应用了消息，对吧？

154
00:28:12,960 --> 00:28:23,200
So no one else can fabricate this data because I'm using that message and I'm using your public key

154
00:28:12,960 --> 00:28:23,200
因此，没有其他人可以伪造这些数据，因为我使用那条消息，并且我使用了你的公钥

155
00:28:23,200 --> 00:28:33,280
in this verification. So now we look at why this gx equals y to the r times r to the s.

155
00:28:23,200 --> 00:28:33,280
在这项验证中。因此现在我们来看为什么这个 gx 等于 y 的 r 次方乘以 r 的 s 次方。

156
00:28:34,240 --> 00:28:44,000
So g to the x, this is a x is a capital x is a message. So in fact we look at the second equation.

156
00:28:34,240 --> 00:28:44,000
所以 g 到 x，这是一个 x 是大写 x 是消息。所以实际上我们看第二个方程。

157
00:28:44,960 --> 00:28:54,559
So second equation means at both sides we can time at both sides with times k, right? So we have

157
00:28:44,960 --> 00:28:54,559
所以第二个方程意味着我们可以在两边同时乘以时间 k，对吧？因此我们有

158
00:28:55,119 --> 00:29:03,119
k times s, then the right hand side k times k to the mass one, that's one.

158
00:28:55,119 --> 00:29:03,119
k 次 s，然后右边 k 次 k 乘以质量 1，那就是 1。

159
00:29:07,839 --> 00:29:17,599
It's congruent to one mod p mass one, right? So that means this k mass one can be cancelled.

159
00:29:07,839 --> 00:29:17,599
与模 p 质量一一致，对吧？这意味着这个 k 质量一可以被约掉。

160
00:29:18,399 --> 00:29:26,079
So that means this k mass one can be cancelled. Then we have x minus x r

160
00:29:18,399 --> 00:29:26,079
因此，这意味着这个 k 质量可以被消去。然后我们有 x 减去 x r

161
00:29:27,679 --> 00:29:37,039
is congruent to x mass minus x r mod p mass one. In other words,

161
00:29:27,679 --> 00:29:37,039
同余于 x 质量减去 x r 模 p 质量 1。换句话说，

162
00:29:37,039 --> 00:29:55,599
this x capital x minus x r, well this is mod p mass one, right? So this can be represented as

162
00:29:37,039 --> 00:29:55,599
这个 x 资本 x 减去 x r，嗯，这是模 p 质量一，对吧？所以这可以表示为

163
00:29:57,680 --> 00:30:04,720
k times s plus let's say t times p mass one.

163
00:29:57,680 --> 00:30:04,720
k 次 s 加上比如说 t 次 p 质量一。

164
00:30:07,759 --> 00:30:14,399
The congruent, that means the difference will be multiple of p mass one.

164
00:30:07,759 --> 00:30:14,399
同余，即差将是 p 的倍数的质量一。

165
00:30:17,119 --> 00:30:21,920
So both sides we mod p mass one, then we have that equation, right?

165
00:30:17,119 --> 00:30:21,920
所以两边模 p 质量一，然后我们就有那个等式，对吧？

166
00:30:24,159 --> 00:30:30,720
The difference will be a multiple of p mass one, multiple we use t to represent this multiple.

166
00:30:24,159 --> 00:30:30,720
差异将是 p 质量的一个倍数，我们用 t 来表示这个倍数。

167
00:30:31,120 --> 00:30:40,319
Okay, this is congruent, but here we have equation, because we use t to represent the difference.

167
00:30:31,120 --> 00:30:40,319
好的，这是相容的，但这里有一个方程，因为我们用 t 来表示差值。

168
00:30:42,160 --> 00:30:56,240
And this implies the capital X equals k times s plus x r times t times p mass one.

168
00:30:42,160 --> 00:30:56,240
并且这表示资本 X 等于 k 乘以 s 加上 x 乘以 r 乘以 t 乘以 p 质量一。

169
00:31:01,360 --> 00:31:22,480
So then the gx, so gx equals g to this part, right? Well, if we mod p,

169
00:31:01,360 --> 00:31:22,480
那么 gx，所以 gx 等于 g 的这一部分，对吧？嗯，如果我们对 p 取模，

170
00:31:23,200 --> 00:31:33,360
mod p, according to the Fermat's theorem, we know that g to the t times p mass one is congruent to

170
00:31:23,200 --> 00:31:33,360
模 p，根据费马定理，我们知道 g 的 t 次方乘以 p 的质数是同余于

171
00:31:33,360 --> 00:31:47,039
one mod p, because p is a prime number. This is a Fermat's theorem. So this part can be removed.

171
00:31:33,360 --> 00:31:47,039
一模 p，因为 p 是质数。这是费马定理。所以这部分可以删除。

172
00:31:47,039 --> 00:31:58,960
And thus we have g to the x equals ks from here, xr from here.

172
00:31:47,039 --> 00:31:58,960
并且，我们从这里得到 g 到 x 等于 ks，从这里得到 xr。

173
00:32:06,720 --> 00:32:07,279
Is that clear?

173
00:32:06,720 --> 00:32:07,279
那是清楚的吗？

174
00:32:07,279 --> 00:32:24,240
Why we have gx equals gxr plus ks? Because start from the second s generation, second equation.

174
00:32:07,279 --> 00:32:24,240
为什么有 gx 等于 gxr 加 ks？因为从第二 s 代开始，第二个方程。

175
00:32:37,279 --> 00:32:54,399
So from this s, so this explains the whole process again. From this s, this equation, right?

175
00:32:37,279 --> 00:32:54,399
因此，这再次解释了整个过程。从这个 s，这个方程，对吧？

176
00:32:55,599 --> 00:33:04,559
Here, at both sides, we times k, that means we move the k mass one to the left hand side.

176
00:32:55,599 --> 00:33:04,559
这里，在两边，我们乘以 k，这意味着我们将 k 质量向左边移动一位。

177
00:33:05,519 --> 00:33:16,879
So we have ks is congruent to x minus xr mod p minus one. The congruent means this x minus x r

177
00:33:05,519 --> 00:33:16,879
因此，我们有 ks ≡ x - xr (mod p - 1)。这里的≡表示 x - xr

178
00:33:16,879 --> 00:33:24,639
can be represented as ks plus t times p minus one, because we have mod p minus one, this operation.

178
00:33:16,879 --> 00:33:24,639
可以表示为 ks 加上 t 乘以 p 减一，因为我们有模 p 减一的运算。

179
00:33:25,440 --> 00:33:34,480
Then this x, the capital X equals k times s plus xr plus t times p minus one.

179
00:33:25,440 --> 00:33:34,480
然后这个 x，大写 X 等于 k 乘以 s 加上 xr 加上 t 乘以 p 减一。

180
00:33:38,400 --> 00:33:49,440
And thus we have the result here, the gx equals g to the xr plus ks. And this is in the exponent,

180
00:33:38,400 --> 00:33:49,440
因此，我们得到了这里的结果，gx 等于 g 的 xr 次方加 ks。这位于指数上。

181
00:33:49,600 --> 00:33:55,120
we have addition, that can be translated to the multiplication, because this is the exponential

181
00:33:49,600 --> 00:33:55,120
我们有加法，可以转化为乘法，因为这是指数的

182
00:33:55,120 --> 00:34:07,920
operation. So this equals g to the xr times g to the ks. g to the x equals y. This is the small x,

182
00:33:55,120 --> 00:34:07,920
操作。因此，这等于 g 的 xr 次方乘以 g 的 ks 次方。g 的 x 次方等于 y。这是小 x，

183
00:34:08,240 --> 00:34:16,079
equals y. This is the small x, private key. So g to the x equals y.

183
00:34:08,240 --> 00:34:16,079
等于 y。这是小 x，私钥。所以 g 的 x 次方等于 y。

184
00:34:18,960 --> 00:34:28,480
And g to the k, k is the one time private key. Well, this equals r.

184
00:34:18,960 --> 00:34:28,480
g 到 k，k 是一次性私钥。嗯，这等于 r。

185
00:34:29,440 --> 00:34:40,240
We can see from the first signature generation, g to the k equals r. And thus we have y to the r,

185
00:34:29,440 --> 00:34:40,240
从第一个签名生成，g 到 k 等于 r。因此，我们有 y 的 r 次方，

186
00:34:41,360 --> 00:34:50,639
y is the public key of Alice. So Bob can use Alice public key, and this r is the signed

186
00:34:41,360 --> 00:34:50,639
y 是 Alice 的公钥。因此 Bob 可以使用 Alice 的公钥，而这个 r 是签名的

187
00:34:51,599 --> 00:35:02,159
signature. And r to the s, s is another signed signature. And p is a public key. And thus Bob

187
00:34:51,599 --> 00:35:02,159
签名。并且 r 到 s，s 是另一个带符号的签名。p 是一个公钥。因此 Bob

188
00:35:02,159 --> 00:35:14,400
can verify gx, capital X, equals y to the r times r to the s. If they're equal, that means the message

188
00:35:02,159 --> 00:35:14,400
可以验证 gx，大写 X，等于 y 的 r 次方乘以 r 的 s 次方。如果它们相等，这意味着信息

189
00:35:15,119 --> 00:35:22,639
is signed by Alice. So we have the mathematical

189
00:35:15,119 --> 00:35:22,639
由 Alice 签署。因此我们得到数学

190
00:35:25,280 --> 00:35:38,400
the equations, derivation to guarantee. Well, this result is correct to show the signature is

190
00:35:25,280 --> 00:35:38,400
方程式、推导保证。嗯，这个结果是正确的，表明特征值是

191
00:35:38,400 --> 00:35:47,519
really generated by Alice, because I'm using Alice, the public key here, to do the verification.

191
00:35:38,400 --> 00:35:47,519
实际上是由 Alice 生成的，因为我正在使用 Alice 的公钥来进行验证。

192
00:35:52,160 --> 00:35:56,800
Okay, let's look at one example. So in this example,

192
00:35:52,160 --> 00:35:56,800
好的，让我们来看一个例子。所以在这个例子中，

193
00:35:56,800 --> 00:36:04,400
so the public key is 11, p is 11, the base g generator is 2,

193
00:35:56,800 --> 00:36:04,400
公钥为 11，p 为 11，基 g 生成元为 2，

194
00:36:05,920 --> 00:36:13,280
well, 2 is the generator of z11. And public key is, the private key is 3. So public key is

194
00:36:05,920 --> 00:36:13,280
嗯，2 是 z11 的生成元。公钥是，私钥是 3。所以公钥是

195
00:36:13,680 --> 00:36:21,840
And public key is, the private key is 3. So public key is g to the x, 3,

195
00:36:13,680 --> 00:36:21,840
公钥是，私钥是 3。因此公钥是 g 的 x 次方，3，

196
00:36:23,760 --> 00:36:35,760
g to the x, that is 2 to the 3 mod 11. That's 8. Suppose the message value is 9, and we choose

196
00:36:23,760 --> 00:36:35,760
g 到 x，即 2 的 3 次方模 11。结果是 8。假设信息值为 9，我们选择

197
00:36:36,480 --> 00:36:50,000
the one time key k to be 7. So k, 7, and p minus 1, 10, the relative prime, and we can get k

197
00:36:36,480 --> 00:36:50,000
一次密钥 k 为 7。因此 k，7，以及 p 减 1，10，互质，我们可以得到 k

198
00:36:50,720 --> 00:37:01,200
minus 1. So k minus 1, in this example, I tell you the result is 3. And we calculate the signature

198
00:36:50,720 --> 00:37:01,200
减 1。所以 k 减 1，在这个例子中，我告诉你结果是 3。然后我们计算符号

199
00:37:01,199 --> 00:37:09,839
r to be g to the k. So base is 2 to the 3, 2 to the k is 7.

199
00:37:01,199 --> 00:37:09,839
r 等于 g 等于 k。所以基数是 2 的 3 次方，2 的 k 次方是 7。

200
00:37:09,840 --> 00:37:33,280
The mod p mod 11, the result here is 7. So s will be a value to be k minus 1

200
00:37:09,840 --> 00:37:33,280
模 p 模 11，这里的结果是 7。因此 s 将是 k 减 1 的值

201
00:37:34,240 --> 00:37:43,200
times the message minus the private key x times r mod p minus 1.

201
00:37:34,240 --> 00:37:43,200
消息次数减去私钥 x 乘以 r 模 p 减 1。

202
00:37:45,840 --> 00:37:59,040
And the value should be, this is 3 times the message is 9, the private key is 3, r is 7,

202
00:37:45,840 --> 00:37:59,040
并且这个值应该是，这是消息的 3 倍，即 9，私钥是 3，r 是 7，

203
00:38:00,000 --> 00:38:08,480
and this result is 3 times

203
00:38:00,000 --> 00:38:08,480
这个结果是 3 倍

204
00:38:11,199 --> 00:38:12,639
minus 12.

204
00:38:11,199 --> 00:38:12,639
负 12。

205
00:38:17,920 --> 00:38:26,559
So this equals minus 36. This is congruent to 4 because we mod 10.

205
00:38:17,920 --> 00:38:26,559
所以这等于负 36。因为我们对 10 取模，所以它等同于 4。

206
00:38:26,719 --> 00:38:40,159
And thus the sign message should be, well, the message is 9, with r to be 7, and s to be 4.

206
00:38:26,719 --> 00:38:40,159
因此，签名消息应该是，嗯，消息是 9，r 应该是 7，s 应该是 4。

207
00:38:45,679 --> 00:38:50,880
In the verification, we compare these two data. The first one is gx.

207
00:38:45,679 --> 00:38:50,880
在验证中，我们比较这两份数据。第一份是 gx。

208
00:38:50,880 --> 00:39:06,160
The first one is gx. g, the base is 2, message is 9, mod p, p is 11, and this result is 6.

208
00:38:50,880 --> 00:39:06,160
第一个是 gx.g，底数为 2，信息为 9，模 p，p 为 11，这个结果是 6。

209
00:39:07,119 --> 00:39:18,879
y is the public key, is 8 from here, y is here. r is, this is r, this is s.

209
00:39:07,119 --> 00:39:18,879
y 是公钥，此处为 8，y 在此处。r 是，这是 r，这是 s。

210
00:39:19,680 --> 00:39:31,599
So r is 7 times, 7 to the s is 4, mod 11. This result is also 6.

210
00:39:19,680 --> 00:39:31,599
所以 r 是 7 倍，7 的 s 次方是 4，模 11。这个结果也是 6。

211
00:39:32,400 --> 00:39:38,720
The equal, that means the signature is correct.

211
00:39:32,400 --> 00:39:38,720
相等，即签名正确。

212
00:39:48,880 --> 00:40:02,720
Any question?

212
00:39:48,880 --> 00:40:02,720
任何问题？

213
00:40:02,719 --> 00:40:18,079
Okay, in part three, we talk about another signature, and this one is quite important.

213
00:40:02,719 --> 00:40:18,079
好的，在第三部分，我们讨论另一个标志性概念，这个概念非常重要。

214
00:40:19,039 --> 00:40:25,679
This is called the bland signature. In some cases, we need to have the bland signature,

214
00:40:19,039 --> 00:40:25,679
这被称为平淡签名。在某些情况下，我们需要有平淡签名，

215
00:40:26,399 --> 00:40:35,279
and we look at what's meaning for bland signature. The basic idea is that a sender

215
00:40:26,399 --> 00:40:35,279
我们来看看平淡签名的含义。基本思想是，发件人

216
00:40:36,399 --> 00:40:45,199
makes a sender to send message m without knowing m. Therefore, blandly,

216
00:40:36,399 --> 00:40:45,199
使发送者发送消息 m 而不知道 m。因此，简单地来说，

217
00:40:46,319 --> 00:40:49,440
this is needed in some e-commerce applications.

217
00:40:46,319 --> 00:40:49,440
这在某些电子商务应用中是必要的。

218
00:40:50,400 --> 00:40:58,320
In another application, just like in the voting scenario, what's your vote?

218
00:40:50,400 --> 00:40:58,320
在另一个应用中，就像在投票场景中一样，你投谁的票？

219
00:40:59,280 --> 00:41:08,960
You don't want to disclose your voting result to some officer. The officer needs to sign his

219
00:40:59,280 --> 00:41:08,960
您不想向某些官员透露您的投票结果。官员需要签署他的

220
00:41:09,920 --> 00:41:19,840
signature on your form. So this is another case. Well, when you guarantee that, well,

220
00:41:09,920 --> 00:41:19,840
您的表格签名。所以这是另一个案例。嗯，当你保证这一点时，嗯，

221
00:41:19,840 --> 00:41:28,159
the form contains the correct signature from the officer. However, the officer will not know

221
00:41:19,840 --> 00:41:28,159
该表格包含官员的正确签名。然而，官员将不知道

222
00:41:28,879 --> 00:41:33,839
your voting form, your voted result.

222
00:41:28,879 --> 00:41:33,839
您的投票表，您的投票结果。

223
00:41:36,239 --> 00:41:45,519
So this is a bland signature, just like, well, this is a scenario. Someone can sign

223
00:41:36,239 --> 00:41:45,519
因此这是一个平淡的签名，就像，嗯，这是一个场景。某人可以签名

224
00:41:46,239 --> 00:41:52,480
the signature. Well, in this hard copy, that's fine.

224
00:41:46,239 --> 00:41:52,480
签名。嗯，在这份纸质副本中，这样是可以的。

225
00:41:53,280 --> 00:42:01,760
Bland, her eyes will not see your content, but can generate the signature. And we won't have

225
00:41:53,280 --> 00:42:01,760
布兰德，她的眼睛不会看到你的内容，但可以生成签名。而我们不会

226
00:42:03,039 --> 00:42:07,840
the same process in the e-commerce in two parties.

226
00:42:03,039 --> 00:42:07,840
电子商务中双方相同的流程。

227
00:42:12,320 --> 00:42:18,159
So bland signature can be generated in the following procedures.

227
00:42:12,320 --> 00:42:18,159
因此，可以通过以下步骤生成平淡的签名。

228
00:42:19,119 --> 00:42:28,239
So we assume that, well, the original message is m. Of course, we sent something different

228
00:42:19,119 --> 00:42:28,239
因此，我们假设原始信息是 m。当然，我们发送了不同的内容

229
00:42:29,119 --> 00:42:37,119
to the sender, right? So it cannot be m. That means from m, we generate m prime.

229
00:42:29,119 --> 00:42:37,119
给发送者，对吧？所以它不能是 m。这意味着从 m，我们生成 m'。

230
00:42:37,119 --> 00:42:48,799
m prime is different. So m prime will not disclose your data information.

230
00:42:37,119 --> 00:42:48,799
m'不同。因此，m'不会泄露您的数据信息。

231
00:42:51,440 --> 00:42:58,960
m cannot be obtained by the sender, and m prime will be signed by sender. So sender will sign

231
00:42:51,440 --> 00:42:58,960
m 无法由发送者获得，而 m'将由发送者签名。因此，发送者将签名

232
00:42:59,519 --> 00:43:05,199
m prime to get a signature s prime. So for m prime,

232
00:42:59,519 --> 00:43:05,199
m' 获取一个特征 s'。因此对于 m'，

233
00:43:06,880 --> 00:43:15,280
we'll assume that we are using the RSA algorithm. So m prime to get signature s prime.

233
00:43:06,880 --> 00:43:15,280
我们假设使用 RSA 算法。因此，用 m 的质数来获取签名 s 的质数。

234
00:43:17,519 --> 00:43:24,559
To generate signature, that means we will use the private key to generate the signature.

234
00:43:17,519 --> 00:43:24,559
为了生成签名，这意味着我们将使用私钥来生成签名。

235
00:43:25,519 --> 00:43:31,360
D mod n, we have the signature. But

235
00:43:25,519 --> 00:43:31,360
D mod n，我们得到特征标。但

236
00:43:33,920 --> 00:43:40,079
in the RSA, suppose in the RSA, this signature generation algorithm,

236
00:43:33,920 --> 00:43:40,079
在 RSA 中，假设在 RSA 中，这个签名生成算法，

237
00:43:41,440 --> 00:43:48,079
the message, I'm using my private key, we generate the signature s prime.

237
00:43:41,440 --> 00:43:48,079
消息，我使用我的私钥，我们生成签名 s'。

238
00:43:48,480 --> 00:43:57,199
Okay, this s prime will be returned to the sender. So sender now can compute the sender's

238
00:43:48,480 --> 00:43:57,199
好的，这个 s prime 将返回给发送者。因此发送者现在可以计算发送者的

239
00:43:57,199 --> 00:44:10,239
signature s of m. That means at the sender side, sender will try to generate s from s prime.

239
00:43:57,199 --> 00:44:10,239
签名 s of m。这意味着在发送端，发送者将尝试从 s'生成 s。

240
00:44:10,719 --> 00:44:19,599
This is the arm blinding procedure. So this is called the blinding procedure.

240
00:44:10,719 --> 00:44:19,599
这是手臂盲法程序。因此，这被称为盲法程序。

241
00:44:19,599 --> 00:44:41,679
Now this is the arm blinding procedure. And this s, well, the generation s should equal

241
00:44:19,599 --> 00:44:41,679
现在这是手臂失明程序。而这个，嗯，生成 s 应该等于

242
00:44:41,759 --> 00:45:00,799
m to the d mod n equals s. We need to guarantee s. Okay, this s contains to be the correct

242
00:44:41,759 --> 00:45:00,799
m 除以 d 模 n 等于 s。我们需要保证 s。好的，这个 s 需要是正确的

243
00:45:00,880 --> 00:45:11,920
signal from the sender. That means it equals the m to the d mod n. So d is the private key of the

243
00:45:00,880 --> 00:45:11,920
信号来自发送者。这意味着它等于 m 模 n 的 d。因此，d 是私钥。

244
00:45:11,920 --> 00:45:23,200
sender. So it looks to be quite just like a magic, magical trick, right? I do not have your

244
00:45:11,920 --> 00:45:23,200
发送者。所以这看起来就像是一个神奇的魔术，对吧？我并没有你的

245
00:45:23,199 --> 00:45:33,919
private key, but somehow I will generate this s. It contains, it equals the message m

245
00:45:23,199 --> 00:45:33,919
私钥，但不知何故我会生成这个 s。它包含，它等于消息 m

246
00:45:34,639 --> 00:45:42,559
to the d mod n. d is the sender's private key. I don't have it, but I can generate the s.

246
00:45:34,639 --> 00:45:42,559
对 d mod n。d 是发送者的私钥。我没有它，但我可以生成 s。

247
00:45:43,199 --> 00:45:56,320
The process can be viewed in this diagram. Well, this is Alice and this is Bob. Alice is the sender.

247
00:45:43,199 --> 00:45:56,320
该过程可在此图中查看。嗯，这是爱丽丝，这是鲍勃。爱丽丝是发送者。

248
00:46:00,559 --> 00:46:02,639
Bob is the sender.

248
00:46:00,559 --> 00:46:02,639
鲍勃是发送者。

249
00:46:02,639 --> 00:46:13,359
So what we've done in this process is, in the blinding process, we will multiply m with another

249
00:46:02,639 --> 00:46:13,359
在此过程中，我们所做的是在盲法过程中，将 m 与另一个数相乘

250
00:46:13,440 --> 00:46:29,840
key. In the blinding process, in the blinding process, we will multiply m with another data.

250
00:46:13,440 --> 00:46:29,840
关键。在盲法过程中，在盲法过程中，我们将 m 与另一份数据相乘。

251
00:46:30,559 --> 00:46:33,680
And this data r is called the one-time key.

251
00:46:30,559 --> 00:46:33,680
此数据 r 称为一次性密钥。

252
00:46:33,919 --> 00:46:48,879
r is a one-time key, random key. So this r, we will, in fact, Alice will choose the data r. r to be

252
00:46:33,919 --> 00:46:48,879
r 是一个一次性密钥，随机密钥。因此，这个 r，实际上是由 Alice 选择数据 r。

253
00:46:48,879 --> 00:46:56,079
one-time key. And m will times r to the e, and then mod p.

253
00:46:48,879 --> 00:46:56,079
一次性密钥。然后计算 m 乘以 r 的 e 次方，再对 p 取模。

254
00:46:57,039 --> 00:47:06,799
And m will times r to the e, and then mod p. So this m prime will be sent to Bob.

254
00:46:57,039 --> 00:47:06,799
m 乘以 r 的 e 次方，然后对 p 取模。因此，这个 m' 将被发送给 Bob。

255
00:47:09,199 --> 00:47:19,440
Alice will choose this r. This r is unknown to Bob. And in this way, m prime will

255
00:47:09,199 --> 00:47:19,440
爱丽丝将选择这个 r。这个 r 对鲍勃来说是未知的。并且以这种方式，m 的质数将会

256
00:47:20,400 --> 00:47:26,559
can conceal the original message m. Is this right?

256
00:47:20,400 --> 00:47:26,559
可以隐藏原始信息 m。这样做正确吗？

257
00:47:30,000 --> 00:47:35,760
The m prime will be sent to Bob. This message contains some random number r.

257
00:47:30,000 --> 00:47:35,760
m' 将发送给 Bob。此消息包含一些随机数 r。

258
00:47:37,119 --> 00:47:45,599
Bob has no idea about r. Thus, Bob cannot get any information from m.

258
00:47:37,119 --> 00:47:45,599
鲍勃对 r 一无所知。因此，鲍勃无法从 m 中获取任何信息。

259
00:47:46,480 --> 00:47:55,839
So Bob will do this signing process. The signing is quite simple to Bob. So Bob will apply his

259
00:47:46,480 --> 00:47:55,839
所以鲍勃将执行这个签名流程。对鲍勃来说，签名过程非常简单。因此鲍勃将应用他的

260
00:47:55,839 --> 00:48:06,559
private key d to sign to generate the signature s prime. The s prime will be returned to Alice.

260
00:47:55,839 --> 00:48:06,559
私钥 d 用于签名以生成签名 s'。s'将被返回给 Alice。

261
00:48:06,639 --> 00:48:18,799
So let's see, s prime equals m prime to the d mod p. So m prime equals m times r e,

261
00:48:06,639 --> 00:48:18,799
所以，我们来看，s' 等于 m' 模 p 的 d 次方。因此，m' 等于 m 乘以 r 的 e 次方。

262
00:48:20,480 --> 00:48:34,559
this to the d mod p. This equals m to the d times r mod p.

262
00:48:20,480 --> 00:48:34,559
这等于 m 的 d 次方乘以 r 模 p。

263
00:48:37,119 --> 00:48:40,960
To the e d mod p.

263
00:48:37,119 --> 00:48:40,960
至于 e d mod p。

264
00:48:44,159 --> 00:48:50,799
Right? Well, according to RSA algorithm, RSA, we know that

264
00:48:44,159 --> 00:48:50,799
对吧？嗯，根据 RSA 算法，RSA，我们知道

265
00:48:52,239 --> 00:49:04,719
r to the e d is congruent to 1 mod p, or previously with mod n. But here we simply use p.

265
00:48:52,239 --> 00:49:04,719
r 到 e 的 d 同余于 1 模 p，或者之前用模 n。但这里我们简单地使用 p。

266
00:49:05,359 --> 00:49:06,399
That's the same thing, right?

266
00:49:05,359 --> 00:49:06,399
那也是一回事，对吧？

267
00:49:09,839 --> 00:49:17,839
So you can refresh your memory. m to the e d is congruent to n mod n.

267
00:49:09,839 --> 00:49:17,839
所以你可以刷新你的记忆。m 到 e 的 d 与 n 模 n 同余。

268
00:49:20,559 --> 00:49:29,839
And we apply the public key e, apply the private key d again. We can get the original message m

268
00:49:20,559 --> 00:49:29,839
并且我们应用公钥 e，再次应用私钥 d。我们可以得到原始信息 m

269
00:49:30,800 --> 00:49:42,880
in the RSA algorithm. So here, the r e d will get back to r, that one time key again,

269
00:49:30,800 --> 00:49:42,880
在 RSA 算法中。因此，这里的红色将返回到 r，那个一次性密钥再次，

270
00:49:44,000 --> 00:49:56,160
1 mod p. So this one will generate, this one equals m d times r mod p.

270
00:49:44,000 --> 00:49:56,160
1 模 p。因此，这个将生成，这个等于 m d 次 r 模 p。

271
00:49:56,159 --> 00:50:02,079
So this is the s prime. Is that clear?

271
00:49:56,159 --> 00:50:02,079
这是 s 的素数。清楚了吗？

272
00:50:05,440 --> 00:50:09,679
Okay, this s prime will be obtained by Alice.

272
00:50:05,440 --> 00:50:09,679
好的，这个 s 素数将由 Alice 获得。

273
00:50:12,000 --> 00:50:22,319
So Alice got s prime. From s prime, Alice will divide this s prime by r

273
00:50:12,000 --> 00:50:22,319
所以 Alice 得到了 s 的质数。从 s 的质数开始，Alice 将这个 s 的质数除以 r

274
00:50:26,799 --> 00:50:42,319
So she will get m to the d times r divided by r mod p. And this equals m d mod p.

274
00:50:26,799 --> 00:50:42,319
所以她将得到 m 乘以 d 乘以 r 除以 r 模 p。这等于 m 乘以 d 模 p。

275
00:50:45,599 --> 00:50:52,399
s prime divided by r equals s prime times r minus 1.

275
00:50:45,599 --> 00:50:52,399
s'除以 r 等于 s'乘以 r 减 1。

276
00:50:52,400 --> 00:50:58,320
The times r minus 1, that's a module inverse.

276
00:50:52,400 --> 00:50:58,320
t = r - 1，这是一个模逆元。

277
00:51:04,240 --> 00:51:13,680
So you see, s prime times r equals s prime times r minus 1.

277
00:51:04,240 --> 00:51:13,680
所以你看，s'乘以 r 等于 s'乘以 r 减 1。

278
00:51:14,480 --> 00:51:29,599
Not because if both sides, we times r, we times r, we mod p, of course this can be canceled, right?

278
00:51:14,480 --> 00:51:29,599
不是因为我们两边都有，我们乘以 r，我们乘以 r，我们取模 p，当然可以约掉，对吧？

279
00:51:29,599 --> 00:51:40,079
This is prime. And according to definition, r minus 1 times r, this is 1 mod p.

279
00:51:29,599 --> 00:51:40,079
这是素数。根据定义，r 减 1 乘以 r，这是 1 模 p。

280
00:51:44,079 --> 00:51:54,559
So of course, with this s prime divided by r, in fact equals s prime times r minus 1.

280
00:51:44,079 --> 00:51:54,559
当然，这个 s'除以 r 实际上等于 s'乘以 r 减 1。

281
00:51:54,559 --> 00:52:00,559
r minus 1 is a module inverse. So how can we do the division operation?

281
00:51:54,559 --> 00:52:00,559
r-1 是模逆。那么我们如何进行除法运算？

282
00:52:01,759 --> 00:52:07,199
Division can be translated to the multiplication of the modular inverse.

282
00:52:01,759 --> 00:52:07,199
除法可以翻译为模逆元的乘法。

283
00:52:07,919 --> 00:52:14,159
Okay, so in nature 2, we studied the modular inverse.

283
00:52:07,919 --> 00:52:14,159
好的，所以在自然 2 中，我们研究了模逆。

284
00:52:15,279 --> 00:52:21,599
We just guarantee modular inverse times the r mod p equals 1. That's a requirement.

284
00:52:15,279 --> 00:52:21,599
我们仅保证模逆元乘以 r 模 p 等于 1。这是要求。

285
00:52:21,599 --> 00:52:36,960
The eyes can get s prime from Bob. So eyes will divide s prime by r.

285
00:52:21,599 --> 00:52:36,960
眼睛可以从 Bob 那里得到 s'。因此，眼睛会将 s'除以 r。

286
00:52:36,960 --> 00:52:44,719
Or we say s prime times r to the minus 1. Then we can get this is s.

286
00:52:36,960 --> 00:52:44,719
或者我们说 s 的导数乘以 r 的负一次方。然后我们可以得到这是 s。

287
00:52:44,799 --> 00:52:56,879
For message m, it's signature to be signed by Bob. This signature is m to the d mod p.

287
00:52:44,799 --> 00:52:56,879
消息 m 的签名应由 Bob 签署。此签名是 m 模 p 的 d 次方。

288
00:52:57,519 --> 00:53:16,000
So this for Bob, the public key is e p. This is the public key. And private key

288
00:52:57,519 --> 00:53:16,000
因此，这是给 Bob 的，公钥是 e p。这是公钥。私钥

289
00:53:16,000 --> 00:53:33,280
is d, right? For Bob. Then you can see this is indeed

289
00:53:16,000 --> 00:53:33,280
是的，对 Bob 来说。然后你可以看到这确实

290
00:53:36,239 --> 00:53:43,199
is generated by using Bob's private key based on the original message m.

290
00:53:36,239 --> 00:53:43,199
由 Bob 的私钥基于原始消息 m 生成。

291
00:53:43,279 --> 00:53:51,759
We have this signature. Although Alice has no idea of Bob's private key,

291
00:53:43,279 --> 00:53:51,759
我们有这个签名。尽管爱丽丝不知道鲍勃的私钥，

292
00:53:52,319 --> 00:54:01,359
but she can successfully generate the signature s. In this signing process,

292
00:53:52,319 --> 00:54:01,359
但她可以成功生成签名 s。在此签名过程中，

293
00:54:01,359 --> 00:54:11,119
Bob has no idea of the original message m. So eyes can know this r.

293
00:54:01,359 --> 00:54:11,119
鲍勃不知道原始信息 m。因此眼睛可以知道这个 r。

294
00:54:13,519 --> 00:54:25,839
Of course, eyes can calculate r minus 1. When eyes obtain s prime from Bob,

294
00:54:13,519 --> 00:54:25,839
当然，眼睛可以计算 r 减 1。当眼睛从 Bob 那里获得 s'时，

295
00:54:26,639 --> 00:54:35,119
so eyes can calculate s prime times r minus 1 mod p, then this equals the signature s.

295
00:54:26,639 --> 00:54:35,119
因此，眼睛可以计算 s 的素数次方乘以 r 减 1 模 p，那么这等于签名 s。

296
00:54:35,119 --> 00:54:50,639
So this is the blind signature generation process.

296
00:54:35,119 --> 00:54:50,639
这是盲签名生成过程。

297
00:54:50,639 --> 00:55:14,159
We have the charms plus signature scheme. This scheme is exactly the process illustrated in this page.

297
00:54:50,639 --> 00:55:14,159
我们有魅力加签名方案。此方案正是本页所展示的过程。

298
00:55:21,440 --> 00:55:32,559
So you can see in this transplant signature, we assume that we're using the RSA algorithm.

298
00:55:21,440 --> 00:55:32,559
因此，您可以看到在这项移植签名中，我们假设我们正在使用 RSA 算法。

299
00:55:33,519 --> 00:55:44,480
And suppose Bob's public key is n and e. His private key is d. The message is m.

299
00:55:33,519 --> 00:55:44,480
假设鲍勃的公钥是 n 和 e，他的私钥是 d。信息是 m。

300
00:55:44,480 --> 00:55:50,639
m should be smaller than n. And Alice chooses a one-time key k.

300
00:55:44,480 --> 00:55:50,639
m 应该小于 n。并且 Alice 选择一个一次性密钥 k。

301
00:55:51,760 --> 00:55:58,719
k should be in the range from 0 to n. We will guarantee that gcd n k is 1.

301
00:55:51,760 --> 00:55:58,719
k 应在 0 到 n 的范围内。我们将保证 gcd(n, k) = 1。

302
00:55:59,679 --> 00:56:06,159
So this will guarantee that we have the k must 1 mod n.

302
00:55:59,679 --> 00:56:06,159
所以这将保证我们有 k 必须 1 mod n。

303
00:56:06,159 --> 00:56:13,039
k is a randomly chosen number. This is called the blinding factor.

303
00:56:06,159 --> 00:56:13,039
k 是随机选取的数字。这被称为盲化因子。

304
00:56:16,799 --> 00:56:27,199
In the blinding process, Alice will compute n times k to the e. Alice knows k.

304
00:56:16,799 --> 00:56:27,199
在盲化过程中，爱丽丝将计算 n 乘以 k 的 e 次方。爱丽丝知道 k。

305
00:56:27,279 --> 00:56:37,279
And in this blinding process, well, when Bob applied his signature, applied his private key d,

305
00:56:27,279 --> 00:56:37,279
在这令人眼花缭乱的进程中，当鲍勃应用他的签名，应用他的私钥 d，

306
00:56:37,519 --> 00:56:51,120
and this m prime d equals this one.

306
00:56:37,519 --> 00:56:51,120
并且这个 m' d 等于这个一个。

307
00:56:53,440 --> 00:56:59,840
m to the d times k times e d.

307
00:56:53,440 --> 00:56:59,840
m^d × k × e^d

308
00:57:00,160 --> 00:57:11,200
Well, in this way, the random number k with an exponent d can be actually can be cancelled.

308
00:57:00,160 --> 00:57:11,200
嗯，这样，具有指数 d 的随机数 k 实际上可以被消除。

309
00:57:11,279 --> 00:57:23,039
We already put the exponent part with a value of e. So e times d mod n. Actually, this equals 1.

309
00:57:11,279 --> 00:57:23,039
我们已将指数部分赋值为 e。所以 e 乘以 d 模 n。实际上，这等于 1。

310
00:57:24,319 --> 00:57:35,039
So in the on-branded case, we have a random number k with an exponent d.

310
00:57:24,319 --> 00:57:35,039
所以，在自有品牌的情况下，我们有一个指数为 d 的随机数 k。

311
00:57:35,759 --> 00:57:45,840
Actually, this equals 1. So in the on-branding, the message we want to get from s prime to s.

311
00:57:35,759 --> 00:57:45,840
实际上，这等于 1。所以在品牌推广中，我们希望从 s'到 s 得到的信息。

312
00:57:46,719 --> 00:57:59,840
So s prime is the signature obtained by Alice. So Alice can get

312
00:57:46,719 --> 00:57:59,840
所以 s 的导数是 Alice 获得的特征值。因此 Alice 可以得到

313
00:57:59,840 --> 00:58:10,720
s prime times the k must 1. So this will get the original signature.

313
00:57:59,840 --> 00:58:10,720
s' 乘以 k 必须等于 1。因此这将得到原始签名。

314
00:58:12,480 --> 00:58:16,640
The reason is because s prime, this is s prime.

314
00:58:12,480 --> 00:58:16,640
原因是 s 的素数，这就是 s 的素数。

315
00:58:16,639 --> 00:58:31,440
So s prime equals m d is equal to m d times k mod n. So from s prime to s,

315
00:58:16,639 --> 00:58:31,440
所以 s'的模 m 等于 md 等于 md 乘以 k 模 n。因此从 s'到 s，

316
00:58:32,400 --> 00:58:39,839
we can simply multiply s prime by k must 1. This will generate the signature s.

316
00:58:32,400 --> 00:58:39,839
我们可以简单地用 k 乘以 s'，必须 1。这将生成签名 s。

317
00:58:47,279 --> 00:59:01,199
So this is the whole process. You can see this is the m prime. m prime to d, we have m d, this is s, this is k.

317
00:58:47,279 --> 00:59:01,199
所以这就是整个过程。您可以看到这是 m 的导数。从 m 导数到 d，我们有 md，这是 s，这是 k。

318
00:59:01,199 --> 00:59:12,559
You have mod n, e d.

318
00:59:01,199 --> 00:59:12,559
您有模 n，e d。

319
00:59:14,879 --> 00:59:26,480
In our RSA algorithm, e d, we choose e d such that it equals, it is congruent to 1 mod phi.

319
00:59:14,879 --> 00:59:26,480
在 RSA 算法中，我们选择 e 和 d，使得 e 和 d 等于，与φ同余 1。

320
00:59:27,199 --> 00:59:35,599
This is a guarantee that k e d mod n equals k.

320
00:59:27,199 --> 00:59:35,599
这是 k e d mod n 等于 k 的保证。

321
00:59:39,119 --> 00:59:44,159
So thus, we can get the s. This is the signature.

321
00:59:39,119 --> 00:59:44,159
因此，我们可以得到 s。这就是签名。

322
00:59:49,280 --> 00:59:53,599
And this signature equals this part

322
00:59:49,280 --> 00:59:53,599
这个签名等于这部分

323
00:59:57,440 --> 00:59:59,599
is s prime.

323
00:59:57,440 --> 00:59:59,599
是素数。

324
01:00:10,800 --> 01:00:18,639
Okay, now we look at this exercise. Suppose we have the copy key to be

324
01:00:10,800 --> 01:00:18,639
好的，现在我们来看这个练习。假设我们拥有复制键。

325
01:00:18,719 --> 01:00:26,879
e equals 5, n is 1, 1, 9. So 1, 1, 9 equals 7 times 17, right?

325
01:00:18,719 --> 01:00:26,879
e 等于 5，n 为 1，1，9。所以 1，1，9 等于 7 乘以 17，对吧？

326
01:00:28,480 --> 01:00:38,480
This p to be 7, q to be 17. The requester wants a signature on the message m equals

326
01:00:28,480 --> 01:00:38,480
此 p 为 7，q 为 17。请求者在消息 m 上需要签名。

327
01:00:39,440 --> 01:00:50,320
37. Suppose he chooses a random blending factor R to be 29. So we need to guarantee that g c d

327
01:00:39,440 --> 01:00:50,320
37. 假设他选择一个随机的混合因子 R 为 29。因此我们需要保证 g c d

328
01:00:51,440 --> 01:01:01,039
R n is 1. In this way, we can calculate our must 1 mod n.

328
01:00:51,440 --> 01:01:01,039
R n 为 1。这样，我们可以计算出我们的必须 1 模 n。

329
01:01:01,199 --> 01:01:10,400
So what's the private key of Sonar? We have the public key, e and n. We are able to calculate

329
01:01:01,199 --> 01:01:10,400
So what's the private key of Sonar? We have the public key, e and n. We are able to calculate

那么 Sonar 的私钥是什么？我们有了公钥 e 和 n。我们能够计算出

330
01:01:11,199 --> 01:01:18,320
the Sonar's private key. And then we should apply the blending phase.

330
01:01:11,199 --> 01:01:18,320
声纳的私钥。然后我们应该应用混合阶段。

331
01:01:18,720 --> 01:01:28,640
So suppose this step 1, step 2, blending phase, step 3, signing phase, step 4 on blending phase.

331
01:01:18,720 --> 01:01:28,640
所以假设这一步 1，步骤 2，混合阶段，步骤 3，签署阶段，步骤 4 在混合阶段。

332
01:01:29,600 --> 01:01:39,600
In the blending phase, that means the message m times R is one time key. We apply the same

332
01:01:29,600 --> 01:01:39,600
在混合阶段，这意味着消息 m 乘以 R 是一次密钥。我们应用相同的

333
01:01:39,599 --> 01:01:53,679
message m times R is one time key. We apply the public key of the Sonar, right?

333
01:01:39,599 --> 01:01:53,679
消息 m 次 R 是一次密钥。我们使用 Sonar 的公钥，对吧？

334
01:01:56,319 --> 01:02:02,960
This is the blending phase. We get m prime. In the signing phase,

334
01:01:56,319 --> 01:02:02,960
这是混合阶段。我们得到 m'。在签名阶段，

335
01:02:02,960 --> 01:02:13,599
this is quite simple. The Sonar will apply his private key to do the signing. That's the m prime

335
01:02:02,960 --> 01:02:13,599
这很简单。Sonar 将应用其私钥进行签名。这就是 m 的质数

336
01:02:15,199 --> 01:02:26,000
to apply the private key d to generate the s prime. In the on-blending phase, it is

336
01:02:15,199 --> 01:02:26,000
将私钥 d 应用于生成 s 素数。在混合阶段，它是

337
01:02:26,000 --> 01:02:41,119
done by the requester. He will get the signature s from s prime times R one time key,

337
01:02:26,000 --> 01:02:41,119
由请求者完成。他将获得 s 从 s'乘以 R 一次密钥的签名 s。

338
01:02:42,559 --> 01:02:47,440
the module inverse of this R mod n.

338
01:02:42,559 --> 01:02:47,440
该 R 模 n 的模逆元

339
01:02:47,440 --> 01:02:54,720
OK, so this is an exercise. Let's have a break for 10 minutes. So in 10 minutes,

339
01:02:47,440 --> 01:02:54,720
好的，这是一个练习。让我们休息 10 分钟。那么，10 分钟后，

340
01:02:55,760 --> 01:03:04,480
you can try to solve this exercise. OK, so let's have a break for 10 minutes.

340
01:02:55,760 --> 01:03:04,480
您可以尝试解决这个练习。好的，那么我们休息 10 分钟。

