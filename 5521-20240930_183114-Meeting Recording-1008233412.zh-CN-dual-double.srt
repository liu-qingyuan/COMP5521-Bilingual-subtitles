1
00:00:00,000 --> 00:00:23,519
Hello. Hello. Hello. Okay. Good evening, everyone. So, this is today's lecture. So, welcome to

1
00:00:00,000 --> 00:00:23,519
大家晚上好。今天，我们将一起探讨今天的讲座内容。欢迎各位的到来。

2
00:00:24,160 --> 00:00:32,719
thank you for your attendance. Today is the day before the holiday tomorrow. You're still here.

2
00:00:24,160 --> 00:00:32,719
感谢您的光临。今天就是明天假期的前一天了，您还在这儿呢。

3
00:00:32,719 --> 00:00:40,799
I'm very glad to see you. Okay. Last time, let's have a brief review about what we have learned

3
00:00:32,719 --> 00:00:40,799
我很高兴见到你。好的。上次，让我们简要回顾一下我们学到了什么，这样更自然易懂。

4
00:00:40,799 --> 00:00:52,879
last time about the digital signature. So, in digital signature in part one,

4
00:00:40,799 --> 00:00:52,879
上次我们讨论了数字签名，那么在第一部分中，关于数字签名的讨论是这样的，...

5
00:00:52,880 --> 00:01:01,440
we finished part one about the RSA algorithm, how this one can be used to generate the RSA signature.

5
00:00:52,880 --> 00:01:01,440
我们完成了关于 RSA 算法的第一部分，介绍了如何使用它来生成 RSA 签名。这一部分内容讲述了 RSA 算法的基本原理及其在生成 RSA 签名中的应用。

6
00:01:02,400 --> 00:01:06,159
So, we have the signature generation and the signature verification.

6
00:01:02,400 --> 00:01:06,159
因此，我们完成了签名生成与验证的过程。

7
00:01:10,240 --> 00:01:17,439
So, because we have the public key and the private key in the RSA algorithm,

7
00:01:10,240 --> 00:01:17,439
因此，在 RSA 算法中，我们已经拥有了公钥和私钥，所以，

8
00:01:18,079 --> 00:01:26,079
and the private key can be used to generate the signature, and the public key can be used by the

8
00:01:18,079 --> 00:01:26,079
私钥可以用来生成签名，而公钥则可以用来..

9
00:01:26,079 --> 00:01:33,519
receiver to verify the correctness of your signature. So, you can see this process, you can see,

9
00:01:26,079 --> 00:01:33,519
请接收方核实您的签名正确性。因此，您可以查看这一过程，您可以查看，

10
00:01:35,039 --> 00:01:46,479
so we use the private key D to generate the signature S, and at the receiver side,

10
00:01:35,039 --> 00:01:46,479
我们使用私钥 D 生成签名 S，接收方将，

11
00:01:47,040 --> 00:01:54,560
receiver will use the sender's public key to do the verification. So, in this way, we guarantee

11
00:01:47,040 --> 00:01:54,560
接收方将使用发送方的公钥进行验证，这样我们就能确保

12
00:01:55,600 --> 00:02:06,880
the message is really from the sender like from Alice. So, we have this example to show how you can

12
00:01:55,600 --> 00:02:06,880
这条信息确实来自发送者，就像来自 Alice 一样。因此，我们提供了一个例子来展示您如何

13
00:02:06,880 --> 00:02:15,040
generate the public key, private key, and how we can generate the signature, and also how can we

13
00:02:06,880 --> 00:02:15,040
生成公钥、私钥以及如何生成签名，以及我们如何操作

14
00:02:15,599 --> 00:02:24,000
apply the Chinese remainder theorem to quickly calculate a large number, but in generation,

14
00:02:15,599 --> 00:02:24,000
应用中国剩余定理快速计算大数，但在生成过程中，

15
00:02:26,239 --> 00:02:34,239
in the verification of the signature. So, step three is verification,

15
00:02:26,239 --> 00:02:34,239
在验证签名的过程中。所以，第三步就是进行验证，

16
00:02:35,919 --> 00:02:37,919
whether the signature is correct.

16
00:02:35,919 --> 00:02:37,919
签名是否正确？

17
00:02:38,399 --> 00:02:45,039
Now, we look at part two, and part two is another signature scheme. We call it to be the

17
00:02:38,399 --> 00:02:45,039
现在，让我们来看第二部分，这部分是另一种签名方案。我们将其称为

18
00:02:45,039 --> 00:02:53,679
ALKMA digital signature. So, this one is based on the DLP problem. So, DLP problem is a discrete

18
00:02:45,039 --> 00:02:53,679
ALKMA 数字签名。因此，这个方案是基于数据泄露防护（DLP）问题。DLP 问题是一个离散的

19
00:02:53,679 --> 00:02:59,919
logarithm problem. So, this one is also believed to be very hard to attack.

19
00:02:53,679 --> 00:02:59,919
对数问题，因此人们普遍认为它很难被破解。

20
00:02:59,919 --> 00:03:07,679
So, now, first, we look at the discrete logarithm problem, just like, you know,

20
00:02:59,919 --> 00:03:07,679
那么，现在，首先，让我们来看看这个离散对数问题，就像你了解的那样，

21
00:03:07,679 --> 00:03:18,239
abbreviation to be DLP problem. The input for this problem, we have the input. So, input is ZP star.

21
00:03:07,679 --> 00:03:18,239
缩写代表数据泄露问题。该问题的输入已知，因此输入为 ZP 星。

22
00:03:18,239 --> 00:03:28,479
So, this is a set. This is a set of DLP problems. So, this is a set of DLP problems. So,

22
00:03:18,239 --> 00:03:28,479
因此，这是一个集合。这是 DLP 问题的集合。这是 DLP 问题的集合。因此，

23
00:03:29,359 --> 00:03:30,159
this is a set

23
00:03:29,359 --> 00:03:30,159
这是一个集合

24
00:03:42,879 --> 00:03:53,199
with all members from 1, 2, 3, till P must 1, and we assume P is a prime number.

24
00:03:42,879 --> 00:03:53,199
从 1, 2, 3，直到 P 的所有成员都必须是 1，我们假设 P 是一个质数。翻译更加自然，易于理解。

25
00:03:53,679 --> 00:04:02,560
So, this set contains all the numbers from 1 to P must 1. And we have another data G in this set.

25
00:03:53,679 --> 00:04:02,560
因此，这个集合包含了从 1 到 P 的所有数字，必须为 1。此外，这个集合中还包含另一个数据 G。

26
00:04:03,119 --> 00:04:13,280
So, G is a generator of ZP star. So, generator, or in some cases, we say it is a primitive root.

26
00:04:03,119 --> 00:04:13,280
因此，G 是 ZP 星的生成器。在某些情况下，我们称之为原根，或者简单地说，它是原根。

27
00:04:23,360 --> 00:04:25,680
So, generator means

27
00:04:23,360 --> 00:04:25,680
那么，生成器指的是

28
00:04:35,439 --> 00:04:36,319
for any i

28
00:04:35,439 --> 00:04:36,319
对于任意的 i

29
00:04:39,839 --> 00:04:41,839
in this ZP star,

29
00:04:39,839 --> 00:04:41,839
在这颗 ZP 恒星中，

30
00:04:41,839 --> 00:04:49,119
so, G i mod P,

30
00:04:41,839 --> 00:04:49,119
因此，G i 模 P，

31
00:04:51,839 --> 00:04:52,719
G i mod P,

31
00:04:51,839 --> 00:04:52,719
G(i) mod P，

32
00:04:56,319 --> 00:04:59,599
and these four members

32
00:04:56,319 --> 00:04:59,599
这四位成员

33
00:05:06,719 --> 00:05:09,919
in ZP star.

33
00:05:06,719 --> 00:05:09,919
在 ZP 型恒星内。

34
00:05:12,719 --> 00:05:19,359
Okay, this is a good property for G to be a generator of ZP star. So, what's the meaning?

34
00:05:12,719 --> 00:05:19,359
好的，这是一个 G 成为 ZP 星生成器的理想属性。那么，这究竟意味着什么？

35
00:05:20,159 --> 00:05:24,479
Well, in fact, we can look at this example. So, in this example,

35
00:05:20,159 --> 00:05:24,479
好吧，实际上我们可以看看这个例子。那么，在这个例子中，

36
00:05:27,839 --> 00:05:38,159
we have table. So, we have the B, the value B, right, can be from 1, 2, 3, 4, 5, 6.

36
00:05:27,839 --> 00:05:38,159
我们有表格。因此，B 的值可以是 1 到 6 中的任何一个。

37
00:05:39,040 --> 00:05:45,520
So, here P is a prime number to be 7. So, this ZP star

37
00:05:39,040 --> 00:05:45,520
因此，这里 P 是一个质数，其值为 7。所以，这颗 ZP 星

38
00:05:47,920 --> 00:05:59,040
is this set X. So, X can take any value from 1 to 6. And we look at which B, B is the base,

38
00:05:47,920 --> 00:05:59,040
因此，X 可以取 1 到 6 之间的任何数值。接下来，我们关注基数 B。

39
00:05:59,040 --> 00:06:05,840
right, B is the base, just like previously the G. So, G i, we look at these two rows.

39
00:05:59,040 --> 00:06:05,840
右边，B 作为基准点，就像之前的 G 一样。因此，我们来看看这两行。

40
00:06:06,479 --> 00:06:17,759
When B equals 3 and B equals 5. So, you can see G B i. So, in this example, it is B i

40
00:06:06,479 --> 00:06:17,759
当 B 等于 3 和 5 时。因此，你可以看到 G B i。在这个例子中，就是 B i

41
00:06:21,199 --> 00:06:21,839
mod P,

41
00:06:21,199 --> 00:06:21,839
模 P，

42
00:06:22,000 --> 00:06:31,919
P is 7. So, we look at BX mod 7, and the result can represent

42
00:06:22,000 --> 00:06:31,919
P 等于 7，所以查看 BX 除以 7 的余数，这个余数可以表示

43
00:06:33,679 --> 00:06:46,399
all members in the set X. So, when we take the B to be the value to be 3, so we can see B1 mod 7

43
00:06:33,679 --> 00:06:46,399
集合 X 中包含所有成员。所以，当我们将 B 设为 3 时，可以观察到 B1 对 7 取模的结果。

44
00:06:46,399 --> 00:06:59,599
is 3, right, because B equals 3. And B squared, that's 3 times 3 is 9, 9 mod 7, we have 2.

44
00:06:46,399 --> 00:06:59,599
因为 B 等于 3，所以 3 的平方是 9，9 除以 7 的余数是 2。

45
00:07:01,199 --> 00:07:14,959
And B cubed, 2 times 3, that's 6. B to the fourth, that's 6 times 3, that's 18,

45
00:07:01,199 --> 00:07:14,959
B 的三次方，2 乘以 3 等于 6。B 的四次方，即 6 乘以 3 等于 18，

46
00:07:15,919 --> 00:07:27,199
mod 7, we have 4. So, 4 times 3, that's 12, 12 mod 7, we have 5. 5 times 3, that's 15,

46
00:07:15,919 --> 00:07:27,199
7 除以余 4，因此 4 乘 3 得 12，12 除以 7 余 5，5 乘 3 得 15，

47
00:07:27,759 --> 00:07:36,639
mod 7, we have 1. And all the results you can see, we can have all members 1, 2, 3, 4, 5, 6,

47
00:07:27,759 --> 00:07:36,639
模 7 运算，我们得到 1。您可以看到所有结果，包括 1，2，3，4，5，6 等所有成员。

48
00:07:36,639 --> 00:07:47,919
all the members in the set X, right? And thus, we say B equals 3, these two are the generators.

48
00:07:36,639 --> 00:07:47,919
集合 X 中所有的成员，对吧？所以，我们说 B 等于 3，这两个就是生成元。

49
00:07:47,920 --> 00:07:53,199
Generators.

49
00:07:47,920 --> 00:07:53,199
发电机

50
00:07:59,759 --> 00:08:06,639
For B equals 3 or 5, so these two data can be the generators in this example. For P

50
00:07:59,759 --> 00:08:06,639
对于 B 等于 3 或 5，这两个数据可以作为本例的生成器。至于 P

51
00:08:07,360 --> 00:08:20,959
equals 7. However, if B equals 2, and the result will be repeated with only

51
00:08:07,360 --> 00:08:20,959
等于 7。但是，如果 B 等于 2，结果将会重复，只有

52
00:08:22,000 --> 00:08:33,519
2, 4, 1, and 2, 4, 1 repeated. So, when B equals 2, we cannot get all members in the set X. So,

52
00:08:22,000 --> 00:08:33,519
2, 4, 1 以及重复的 2, 4, 1。所以，当 B 值为 2 时，无法获取集合 X 中的全部成员。

53
00:08:33,519 --> 00:08:47,039
set X is ZP star, right? In other words, B cannot be 2 or 4 or 6 to be the generator.

53
00:08:33,519 --> 00:08:47,039
集合 X 是 ZP 星，对吧？换句话说，B 不能取 2、4 或 6 作为生成器。这样的表达更自然、易懂。

54
00:08:47,759 --> 00:09:00,399
We need to guarantee when I take the value from 1 to 6, the result can list all members in the set

54
00:08:47,759 --> 00:09:00,399
我们需要确保从 1 到 6 取值时，结果能够列出集合中的所有成员

55
00:09:00,399 --> 00:09:10,879
X. Is that clear? Okay, so this is the definition about the generator. So, in some cases,

55
00:09:00,399 --> 00:09:10,879
X.这清楚吗？好的，那么这里是对发生器的定义。在某些情况下，

56
00:09:10,879 --> 00:09:20,959
we call it to be the primitive root. And given that B is a number in the set ZP star,

56
00:09:10,879 --> 00:09:20,959
我们称之为原根。并且 B 是集合 ZP 星中的数，

57
00:09:21,920 --> 00:09:32,720
and this is create logarithm problem, we'll ask you to find a unique number A. So, this A is

57
00:09:21,920 --> 00:09:32,720
这是创建对数问题，我们将要求你找到一个唯一的数字 A。这个 A 是这样的

58
00:09:32,720 --> 00:09:44,879
smaller than the P, such that G to the A is congruent to B more P. Okay, we want to find

58
00:09:32,720 --> 00:09:44,879
小于 P，使得 G 与 A 的对应等于 B 与 P 的对应。好的，我们要寻找

59
00:09:44,960 --> 00:09:57,840
this exponent number A such that G to the A more P equals B. So, we denote this value A as discrete

59
00:09:44,960 --> 00:09:57,840
这是指这样一个指数数 A，即 G 的 A 次方加上 P 等于 B。我们把这个值 A 称作离散值。

60
00:09:57,840 --> 00:10:12,399
log of the number B for the base G more P. So, we have this GP the meaning. So, in fact, if we have

60
00:09:57,840 --> 00:10:12,399
以 G 为底，数字 B 的对数加上 P。因此，我们得到 GP 的含义。实际上，如果我们有

61
00:10:13,360 --> 00:10:24,639
for A, if we have A, G and P to calculate B, this is easy, right?

61
00:10:13,360 --> 00:10:24,639
对于 A 而言，只要我们有 A、G 和 P 这三个条件来计算 B，那就非常简单了，对吧？

62
00:10:27,600 --> 00:10:40,240
With the value A, G, P to calculate B, it is easy. However, with the G, with G, this generator, P

62
00:10:27,600 --> 00:10:40,240
使用 A、G、P 值计算 B 很简单。但是，使用 G 值，以及这个生成器，P 值，情况就不同了。

63
00:10:41,200 --> 00:10:51,120
and B to calculate A, this is very difficult, very difficult.

63
00:10:41,200 --> 00:10:51,120
从 B 计算 A 非常困难，这一点非常明确。

64
00:10:55,840 --> 00:11:07,759
So, currently, we do not have a convenient way to get A easily. So, this is actually an exponential

64
00:10:55,840 --> 00:11:07,759
因此，目前我们还没有便捷途径轻松获取 A。这实际上是一个指数过程

65
00:11:07,840 --> 00:11:15,439
problem where probably we need to try all possibilities. So, we have this assumption.

65
00:11:07,840 --> 00:11:15,439
可能需要尝试所有可能性的问题，因此我们提出了这个假设。

66
00:11:15,439 --> 00:11:23,679
This assumption is called the DL assumption. So, this assumption says there is no efficient

66
00:11:15,439 --> 00:11:23,679
这个假设被称为 DL 假设。也就是说，没有有效的

67
00:11:23,679 --> 00:11:33,200
algorithm in polynomial time. So, non-exponential time to solve DL problem. So, this is DL problem,

67
00:11:23,679 --> 00:11:33,200
算法可以在多项式时间内完成。所以，解决深度学习问题的不是指数级时间。因此，这是一个深度学习问题，翻译得更加自然和易于理解。

68
00:11:33,200 --> 00:11:49,360
okay? Given G, P, B to get A, this is the DL problem. Well, today, it is still widely believed

68
00:11:33,200 --> 00:11:49,360
给定 G、P、B 得到 A，这就是深度学习问题。嗯，如今，人们仍然普遍认为

69
00:11:49,360 --> 00:11:57,440
that this assumption holds. It is true, very difficult. So, difficulty is said is similar

69
00:11:49,360 --> 00:11:57,440
这个假设成立。确实，这非常困难。因此，所说的困难是类似的

70
00:11:58,080 --> 00:12:09,360
to the RSA algorithm. When you have a big N, you will find P times Q, this factorization.

70
00:11:58,080 --> 00:12:09,360
到 RSA 算法。当 N 很大时，你会找到 P 和 Q 的乘积，这就是因式分解。

71
00:12:15,360 --> 00:12:22,560
The difficulty of factorization will be similar to this DL problem, similar difficulty.

71
00:12:15,360 --> 00:12:22,560
因子分解的难度与这个深度学习问题相当，难度相似，翻译得更加自然易懂。

72
00:12:27,440 --> 00:12:41,040
Given that just like the P can be very large with a size like to be 1 or 24 bits, okay? A very large

72
00:12:27,440 --> 00:12:41,040
由于 P 的位数可以非常大，类似于 1 位或 24 位，好吗？非常大

73
00:12:41,040 --> 00:12:50,400
number. In that case, it is difficult for you to calculate the A given B.

73
00:12:41,040 --> 00:12:50,400
在那种情况下，您很难根据 B 来计算 A。这样的表达更自然、易懂。

74
00:12:50,399 --> 00:13:06,240
So, here we have explained this table, right? Just we list the base B, and when B equals 1, 2, 3, 4, 5, 6,

74
00:12:50,399 --> 00:13:06,240
那么，这里我们已经对这个表格进行了说明，对吧？我们只列出了基础 B，当 B 取 1、2、3、4、5、6 这些值时，

75
00:13:06,879 --> 00:13:17,199
and B, I, more P, what's the result in this table? And we can see only when B equals 3 or 5,

75
00:13:06,879 --> 00:13:17,199
并且 B、I、更多 P，这个表格的结果是什么？我们只能看到当 B 等于 3 或 5 时，

76
00:13:18,080 --> 00:13:26,800
we can get all possible result to make the result to equal the set ZP star.

76
00:13:18,080 --> 00:13:26,800
我们可以获取所有可能的结果，使结果与 ZP 星集合相等。

77
00:13:29,680 --> 00:13:35,120
So, according to previous table, we look at how can we solve the DLP problem.

77
00:13:29,680 --> 00:13:35,120
因此，根据前面的表格，我们来看看如何解决数据泄露问题吧。

78
00:13:35,759 --> 00:13:54,240
As we know, if the base equals B or G equals 3. So, G equals 3, 3 squared plus 7 is 2.

78
00:13:35,759 --> 00:13:54,240
我们知道，如果基数是 B 或者 G 等于 3。那么，3 的平方加 7 等于 2。

79
00:13:54,240 --> 00:14:06,720
So, for this discrete log of 2, we want to get its exponent. So, exponent number should be 2 here.

79
00:13:54,240 --> 00:14:06,720
因此，对于 2 的这个离散对数，我们想要找到它的指数。这里的指数应该是 2。

80
00:14:07,680 --> 00:14:23,279
So, the discrete log of 2 for the base 3, this is G mod 7, this is P. The exponent in this example

80
00:14:07,680 --> 00:14:23,279
因此，2 对 3 的离散对数，即 G 模 7，即 P。在这个例子中，指数为

81
00:14:23,279 --> 00:14:38,480
should be 2. Well, for this example, because 3 cubed plus 7, we have 6. And this discrete log of 6,

81
00:14:23,279 --> 00:14:38,480
应该是 2。嗯，在这个例子中，因为 3 的立方加 7 等于 6，所以 6 的离散对数就是 6，

82
00:14:41,839 --> 00:14:52,720
for the base 3 mod 7, the exponent should be 3. And similarly, this 5, we have the result to be

82
00:14:41,839 --> 00:14:52,720
对于基数 3 除以 7，指数应为 3。类似地，对于这个 5，结果应为

83
00:14:54,240 --> 00:15:06,720
5. So, how about this one? Well, if the base is 2 and the B is 4, if base is 2

83
00:14:54,240 --> 00:15:06,720
那么，这个方案如何？嗯，如果底数是 2，B 等于 4，如果底数是 2

84
00:15:08,799 --> 00:15:13,839
and the result is 4. So, in fact, we can find two cases.

84
00:15:08,799 --> 00:15:13,839
结果是 4，实际上我们可以找到两种情况。所以，翻译成中文后，这句话读起来更加自然和易懂。

85
00:15:14,480 --> 00:15:25,360
This is case 1. This is case 2. And this shows that the exponent can be either 2 or 5. So, we do not

85
00:15:14,480 --> 00:15:25,360
这是案例 1。这是案例 2。由此可见，指数可以是 2 或 5。所以，我们并不

86
00:15:25,360 --> 00:15:42,639
have a unique result. The result can be either 2 or 5. But, because the B, G to the G squared mod 7,

86
00:15:25,360 --> 00:15:42,639
结果必须唯一。结果可以是 2 或 5。但是，由于 B 和 G 对 7 取模等于 G 的平方，

87
00:15:42,799 --> 00:15:48,000
is 4, and also G to the 5 mod 7, is also 4.

87
00:15:42,799 --> 00:15:48,000
它等于 4，同时也是 5 除以 7 的余数，结果仍然是 4。

88
00:15:51,759 --> 00:15:58,480
So, the reason is because G equals 2 is not a generator.

88
00:15:51,759 --> 00:15:58,480
因此，原因在于 G 等于 2 并非生成器。这样的表述更为自然易懂。

89
00:15:58,560 --> 00:16:14,240
The result will not be unique. So, this is not allowed. We must choose the

89
00:15:58,560 --> 00:16:14,240
结果不会唯一，所以这不允许。我们必须做出选择

90
00:16:15,039 --> 00:16:23,360
the base G to be a generator, such that in this discrete log calculation, the result will be unique.

90
00:16:15,039 --> 00:16:23,360
基础 G 需作为生成器，确保在此离散对数计算中结果唯一，表达更自然易懂。

91
00:16:28,639 --> 00:16:39,600
Okay, based on the DLP problem, we look at how we can construct some of the public key and private

91
00:16:28,639 --> 00:16:39,600
好的，根据数据泄露防护（DLP）问题，我们来探讨如何构建一些公钥和私钥

92
00:16:39,600 --> 00:16:48,639
key. And now we look at for this DLP problem, some property for this problem. If P is small,

92
00:16:39,600 --> 00:16:48,639
key. 现在我们就来分析这个数据泄露问题的一些特性。如果 P 值较小，

93
00:16:49,519 --> 00:16:57,279
discrete log can be found by exhaustive search. Now, we can try all possible of i.

93
00:16:49,519 --> 00:16:57,279
离散对数可以通过穷举搜索来确定。现在，我们可以尝试所有可能的 i 值。

94
00:16:59,279 --> 00:17:04,559
So, i, we can exhaustive search i in this set,

94
00:16:59,279 --> 00:17:04,559
因此，我们可以在该集合中对 i 进行穷举搜索

95
00:17:07,759 --> 00:17:12,559
JP star, right? From 1, 2, 3,

95
00:17:07,759 --> 00:17:12,559
JP 明星，对吧？从一、二、三，

96
00:17:12,559 --> 00:17:42,559
4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 52, 53, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54

96
00:17:12,559 --> 00:17:42,559
4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 52, 53, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54

97
00:17:42,559 --> 00:17:53,919
trial or possibilities to see which exponent to make the result equals the given p, okay?

97
00:17:42,559 --> 00:17:53,919
尝试或探索不同的指数，看看哪个可以使结果等于给定的 p，可以吗？

98
00:17:58,159 --> 00:18:06,639
Well, we will make the p to be very large. So the size of prime p for which dl can be computed

98
00:17:58,159 --> 00:18:06,639
嗯，我们将把 p 设得非常大。这样，对于可以计算 dl 的素数 p，其大小就会变得很大

99
00:18:07,200 --> 00:18:13,759
is approximately the same size, the same as the size of integers that can be

99
00:18:07,200 --> 00:18:13,759
大约大小相同，与整数的大小相当

100
00:18:13,759 --> 00:18:21,920
factored. So normally we will choose the p to be one or 24 bits. At this moment,

100
00:18:13,759 --> 00:18:21,920
因子化后，我们通常会选择 p 为 1 位或 24 位。目前，

101
00:18:23,040 --> 00:18:34,560
this size is believed to be quite secure. For the deal problem, this is in fact an example

101
00:18:23,040 --> 00:18:34,560
这个尺寸被认为非常安全。对于交易问题，这实际上是一个例子

102
00:18:34,960 --> 00:18:45,759
one-way function. So one function means from g, p, and a to get,

102
00:18:34,960 --> 00:18:45,759
单向函数，也就是说，一个函数意味着从 g、p 和 a 出发，得到，这样的表述更为自然和易懂。

103
00:18:48,639 --> 00:18:53,039
or we say x, to get y. So this

103
00:18:48,639 --> 00:18:53,039
我们说用 x 来表示，以得到 y。因此，这里是...

104
00:18:54,000 --> 00:19:10,639
is, this means we can calculate the function g to the x mod p to get y. Finding fx, this is easy.

104
00:18:54,000 --> 00:19:10,639
这意味着我们可以通过计算函数 g 的 x 模 p 来得到 y。找到 fx 非常简单。

105
00:19:11,599 --> 00:19:19,839
However, given y, finding x, to certify this equation, it is hard. In the deal problem,

105
00:19:11,599 --> 00:19:19,839
然而，给定 y 值，要找到 x 值以验证这个等式是困难的。在交易问题中，...

106
00:19:19,839 --> 00:19:31,359
that means given g, p, y to find x, this is very difficult because you need to guarantee

106
00:19:19,839 --> 00:19:31,359
给定 g, p, y 来求解 x，这相当困难，因为需要确保

107
00:19:31,439 --> 00:19:49,519
p gx mod p equals y. So this is almost impossible, okay? If the p is very large, to get this x is

107
00:19:31,439 --> 00:19:49,519
p gx mod p 等于 y。这几乎是不可能的，如果 p 非常大，那么要得到这个 x 就非常困难了，好吧？

108
00:19:50,079 --> 00:20:00,319
almost impossible. So based on this good property, we have the l comma signature scheme.

108
00:19:50,079 --> 00:20:00,319
几乎不可能实现。基于这一良好特性，我们得到了 l 逗号签名方案。

109
00:20:01,359 --> 00:20:08,240
So you can see different cryptography based on different mathematical problems. The RSA is based

109
00:20:01,359 --> 00:20:08,240
您可以了解到基于不同数学问题的多种密码学。RSA 算法基于

110
00:20:08,240 --> 00:20:16,959
on the factorization of a big number, the difficulty. And this one is based on the difficulty of the deal

110
00:20:08,240 --> 00:20:16,959
关于大数分解的难度问题。这个问题基于交易难度

111
00:20:16,959 --> 00:20:26,319
problem. This scheme is based on the difficulty of computing discrete logarithm over the zp

111
00:20:16,959 --> 00:20:26,319
该方案基于在 zp 上计算离散对数的难度，这种表述更为自然易懂

112
00:20:26,480 --> 00:20:35,679
over this set. So p is prime. In this signature scheme, we have the setup and the key generation

112
00:20:26,480 --> 00:20:35,679
在这个集合上。所以 p 是素数。在此签名方案中，我们拥有设置阶段和密钥生成过程

113
00:20:36,240 --> 00:20:47,439
step. And suppose Alice is the one to use this scheme. Alice will choose large prime p.

113
00:20:36,240 --> 00:20:47,439
步骤。假设爱丽丝采用此方案。她将选择一个大素数 p。

114
00:20:48,160 --> 00:20:58,160
Well, so p minus one, p is an odd number. So p minus one is an even number, right? Even number.

114
00:20:48,160 --> 00:20:58,160
好吧，那么 p 减去 1，p 是一个奇数，所以 p 减去 1 就是一个偶数，对吧？偶数。

115
00:20:58,160 --> 00:21:05,600
So seven, if p equals seven, p minus one is six. Six is an even number. So even number must have

115
00:20:58,160 --> 00:21:05,600
因此七，如果 p 等于七，那么 p 减一等于六。六是一个偶数。所以任何偶数都必须

116
00:21:05,600 --> 00:21:15,440
some prime factor. And we will require p minus one has a large prime factor. So p minus one is

116
00:21:05,600 --> 00:21:15,440
一些质因数。我们还需要 p 减一拥有一个大质因数。因此，p 减一就是

117
00:21:15,840 --> 00:21:21,120
has a large prime factor. So this is for the security purpose.

117
00:21:15,840 --> 00:21:21,120
有一个大质因数，因此这是为了安全考虑。

118
00:21:26,880 --> 00:21:27,759
Security purpose.

118
00:21:26,880 --> 00:21:27,759
安全用途。

119
00:21:31,519 --> 00:21:44,559
Then for the given p, we are able to know which data is a primitive root

119
00:21:31,519 --> 00:21:44,559
对于给定的 p，我们可以知道哪些数据是本原根

120
00:21:44,559 --> 00:21:49,839
or primitive element. So this is the meaning of generator.

120
00:21:44,559 --> 00:21:49,839
因此，这就是生成器的意义。

121
00:21:53,039 --> 00:22:02,639
So we choose one data to be the generator to the prime number p, okay? So given the p is prime,

121
00:21:53,039 --> 00:22:02,639
我们选择一个数据作为生成素数 p 的生成器，好的。既然 p 是素数，那么，对吧？

122
00:22:02,639 --> 00:22:09,519
the multiple number can be the generator. So we choose one. And then Alice will choose

122
00:22:02,639 --> 00:22:09,519
多个数字都可以作为生成器。因此我们挑选一个，随后爱丽丝将进行选择

123
00:22:10,079 --> 00:22:22,799
x, small x as her private key and calculate the gx small p to get y. The public key is p, g and y.

123
00:22:10,079 --> 00:22:22,799
以 x 作为私钥，计算 gx small p 得到 y。公钥为 p、g 和 y。

124
00:22:23,599 --> 00:22:33,039
The primary key for Alice is this x, right? From x to get y is easy.

124
00:22:23,599 --> 00:22:33,039
爱丽丝的主键是这个 x，对吧？从 x 到 y 转换很简单。

125
00:22:33,039 --> 00:22:46,000
And then to sign a message, this is a big x. Alice needs to choose an integer k. So this k,

125
00:22:33,039 --> 00:22:46,000
然后进行消息签名，这是一个大 X。Alice 需要选择一个整数 k。因此，这个 k，

126
00:22:47,839 --> 00:22:55,920
we can say this k is a one-time random key.

126
00:22:47,839 --> 00:22:55,920
我们可以这么说，这个 k 是一个一次性随机生成的密钥。

127
00:23:03,039 --> 00:23:21,119
For one message x, we will choose one key, one different key, k. So this key k should be

127
00:23:03,039 --> 00:23:21,119
对于消息 x，我们将选择一个密钥，一个不同的密钥 k。那么，这个密钥 k 应当是

128
00:23:21,119 --> 00:23:28,879
smaller than or equal to p minus one. And also we need to guarantee that the gcd, k and p minus one

128
00:23:21,119 --> 00:23:28,879
小于等于 p 减一的值。同时，我们还需确保最大公约数 k 与 p 减一

129
00:23:28,880 --> 00:23:36,560
is one, the relative prime, because we need to calculate this module inverse. So this will

129
00:23:28,880 --> 00:23:36,560
是一个相对质数，因为我们需要计算这个模逆元。因此，这

130
00:23:36,560 --> 00:23:57,600
guarantee that we have the k minus one mod p minus one. So there are relatively primes

130
00:23:36,560 --> 00:23:57,600
保证我们有 k 减一模 p 减一，它们是互质的。这样的表述更为自然易懂。

131
00:23:57,599 --> 00:24:04,319
and this means we are able to calculate the module inverse of k mod p minus one.

131
00:23:57,599 --> 00:24:04,319
这意味着我们可以计算出 k 模 p 减一的模逆，表述更为自然。

132
00:24:06,000 --> 00:24:17,439
And then Alice will calculate gk mod p to be r. Well, in this way, r will be the signature.

132
00:24:06,000 --> 00:24:17,439
然后，爱丽丝将计算 gk 模 p 得到 r。嗯，这样一来，r 就变成了签名。

133
00:24:18,080 --> 00:24:28,480
So rs will be the signature. So you can see the k is a one-time random key, right? But gk mod p

133
00:24:18,080 --> 00:24:28,480
因此，rs 将是签名。您可以看到 k 是一个一次性随机密钥，对吧？但 gk mod p

134
00:24:29,200 --> 00:24:43,200
equals r, the r will be no. However, with r, you cannot know the k. So this key k will not be

134
00:24:29,200 --> 00:24:43,200
等于 r 时，r 将是编号。但有了 r，你却无法得知 k 的值。所以这个密钥 k 就不会存在。

135
00:24:44,160 --> 00:24:54,160
disclosed. The receiver will only get r and s. Now we look at what's s. So s equals

135
00:24:44,160 --> 00:24:54,160
揭示信息。接收者只能获得 r 和 s。现在我们来探讨 s 的含义。因此，s 等于

136
00:24:55,920 --> 00:25:03,680
module inverse of k minus one. Here we mod p minus one. So we have k minus one times,

136
00:24:55,920 --> 00:25:03,680
模块逆元 k 减 1。在这里我们对 p 减 1 取模，所以得到 k 减 1 乘以，

137
00:25:03,680 --> 00:25:17,840
this is the message x minus the private key of Alice times r. So r from here, and Alice has a

137
00:25:03,680 --> 00:25:17,840
这是消息 x 减去爱丽丝的私钥与 r 相乘。因此，r 从这里开始，爱丽丝有

138
00:25:17,840 --> 00:25:27,920
private key, right? So of course Alice is able to calculate the k minus one times the message

138
00:25:17,840 --> 00:25:27,920
私钥，没错吧？因此 Alice 当然可以计算出密文减去 1 倍的值

139
00:25:27,920 --> 00:25:38,240
minus her private key times r and then mod p minus one to be another signature s.

139
00:25:27,920 --> 00:25:38,240
私钥 r 乘以 p 减一后取模 p，得到另一个签名 s。

140
00:25:40,720 --> 00:25:54,400
The send message is the message end with the r and s. r and s will be sent along with x to the

140
00:25:40,720 --> 00:25:54,400
发送的消息是以“r”和“s”结尾的，这些字符将与“x”一同发送。

141
00:25:54,400 --> 00:26:06,960
receiver like Bob. When Bob received this message, Bob will do the signature verification.

141
00:25:54,400 --> 00:26:06,960
当鲍勃收到这条信息时，他将执行签名验证操作。

142
00:26:07,759 --> 00:26:20,400
To verify the message, Bob will do the comparison of g to the x and y to the r times r to the s.

142
00:26:07,759 --> 00:26:20,400
为了验证信息，鲍勃将比较 g 与 x，以及 y 与 r 的 r 的 s 次方。这样的表述更加自然易懂。

143
00:26:25,120 --> 00:26:26,480
So y is the public key.

143
00:26:25,120 --> 00:26:26,480
因此，y 是公钥。

144
00:26:29,920 --> 00:26:43,280
So these are the public key, public key now g, p, and y to be known by receiver by Bob.

144
00:26:29,920 --> 00:26:43,280
这些就是公钥，包括 g、p 和 y，接收方鲍勃需要了解这些信息。

145
00:26:44,240 --> 00:26:57,039
g, p, y is a public key to be known by anyone else. Okay, we want to know why this equation is

145
00:26:44,240 --> 00:26:57,039
g, p, y 是一个公开的公钥，任何人都可以知道。那么，这个等式为什么是这样的呢？

146
00:26:57,039 --> 00:27:10,079
true. The gx equals yr times rs. That means your signature is correct. So of course you can see

146
00:26:57,039 --> 00:27:10,079
gx 等于 yr 乘以 rs，这说明你的签名是对的。所以当然你能看到

147
00:27:10,079 --> 00:27:13,359
the receiver will use Alice, the public key,

147
00:27:10,079 --> 00:27:13,359
接收者将使用 Alice 的公钥，表达更为自然流畅

148
00:27:20,240 --> 00:27:28,559
in the verification, right? y is the public key of Alice. So this public key will be sent to Bob.

148
00:27:20,240 --> 00:27:28,559
在验证过程中，对吧？这个公钥是 Alice 的，将会发送给 Bob。

149
00:27:29,200 --> 00:27:38,480
So Bob will use Alice's public key r in the verification. So in this way Bob will guarantee

149
00:27:29,200 --> 00:27:38,480
因此，鲍勃将使用爱丽丝的公钥 r 进行验证，以此确保

150
00:27:38,480 --> 00:27:47,679
the message is really from Alice because I'm using your public key y in this verification. So small r,

150
00:27:38,480 --> 00:27:47,679
这条消息确实来自 Alice，因为我正在使用您的公钥 y 进行验证。所以这个 r 非常小，

151
00:27:48,000 --> 00:27:54,320
is really from Alice because I'm using your public key y in this verification.

151
00:27:48,000 --> 00:27:54,320
确实是从 Alice 那里来的，因为我正在使用你的公钥 y 进行验证，这是真的。

152
00:27:55,120 --> 00:28:04,400
So small r, small s are the signed signature you sent to me. I use your public key y in the

152
00:27:55,120 --> 00:28:04,400
如此微小的 r 和 s 是您发送给我的签名。我使用您的公钥 y 在

153
00:28:04,400 --> 00:28:12,880
verification. So g is the public key and also I apply the message in the verification, right?

153
00:28:04,400 --> 00:28:12,880
验证。因此，g 是公钥，我还将消息用于验证，对吗？

154
00:28:12,960 --> 00:28:23,200
So no one else can fabricate this data because I'm using that message and I'm using your public key

154
00:28:12,960 --> 00:28:23,200
没有人能伪造这些数据，因为我在使用这条信息，并且我使用了您的公钥

155
00:28:23,200 --> 00:28:33,280
in this verification. So now we look at why this gx equals y to the r times r to the s.

155
00:28:23,200 --> 00:28:33,280
在这个验证中。现在我们来探讨为什么 gx 等于 y 的 r 次方乘以 r 的 s 次方。这个表述更加自然易懂。

156
00:28:34,240 --> 00:28:44,000
So g to the x, this is a x is a capital x is a message. So in fact we look at the second equation.

156
00:28:34,240 --> 00:28:44,000
因此，g 到 x，这里 x 是大写的 X，代表一个信息。实际上，我们关注第二个方程。

157
00:28:44,960 --> 00:28:54,559
So second equation means at both sides we can time at both sides with times k, right? So we have

157
00:28:44,960 --> 00:28:54,559
第二个方程的意思是，我们可以同时对等式的两边乘以 t 的 k 次方，对吧？那么，我们得到

158
00:28:55,119 --> 00:29:03,119
k times s, then the right hand side k times k to the mass one, that's one.

158
00:28:55,119 --> 00:29:03,119
k 次 s 相乘，接着右边是 k 次方乘以 m 次方，结果就是 1。

159
00:29:07,839 --> 00:29:17,599
It's congruent to one mod p mass one, right? So that means this k mass one can be cancelled.

159
00:29:07,839 --> 00:29:17,599
它与模 p 质量 1 相同，对吧？这意味着这个 k 质量 1 可以被消去。

160
00:29:18,399 --> 00:29:26,079
So that means this k mass one can be cancelled. Then we have x minus x r

160
00:29:18,399 --> 00:29:26,079
这意味着这个 k 质量可以相互抵消。因此，我们得到 x 减去 xr

161
00:29:27,679 --> 00:29:37,039
is congruent to x mass minus x r mod p mass one. In other words,

161
00:29:27,679 --> 00:29:37,039
等于 x 质量减去 x 乘以 r，模 p 质量一。换句话说，

162
00:29:37,039 --> 00:29:55,599
this x capital x minus x r, well this is mod p mass one, right? So this can be represented as

162
00:29:37,039 --> 00:29:55,599
这 x 的资本 x 减去 x 的 r，嗯，这是模 p 的质量一，对吧？所以这可以表示为

163
00:29:57,680 --> 00:30:04,720
k times s plus let's say t times p mass one.

163
00:29:57,680 --> 00:30:04,720
k 次 s 加上大约 t 次 p 质量 1（更自然地表达）。

164
00:30:07,759 --> 00:30:14,399
The congruent, that means the difference will be multiple of p mass one.

164
00:30:07,759 --> 00:30:14,399
这意味着差值将是 p 质量一的整数倍。

165
00:30:17,119 --> 00:30:21,920
So both sides we mod p mass one, then we have that equation, right?

165
00:30:17,119 --> 00:30:21,920
所以两边取模 p 后质量为 1，那么我们就得到了这个方程，对吗？

166
00:30:24,159 --> 00:30:30,720
The difference will be a multiple of p mass one, multiple we use t to represent this multiple.

166
00:30:24,159 --> 00:30:30,720
差别的质量将是 p 质量的一个倍数，我们用 t 来表示这个倍数，表达更为自然。

167
00:30:31,120 --> 00:30:40,319
Okay, this is congruent, but here we have equation, because we use t to represent the difference.

167
00:30:31,120 --> 00:30:40,319
好的，这很一致，但这里有一个方程，因为我们用 t 来表示差异。这样的表述更自然、易懂。

168
00:30:42,160 --> 00:30:56,240
And this implies the capital X equals k times s plus x r times t times p mass one.

168
00:30:42,160 --> 00:30:56,240
这意味着首字母大写的 X 等于 k 乘以 s 加上 x 乘以 r 乘以 t 乘以 p，即质量 1。

169
00:31:01,360 --> 00:31:22,480
So then the gx, so gx equals g to this part, right? Well, if we mod p,

169
00:31:01,360 --> 00:31:22,480
那么，gx 等于 g 的这一部分，对吧？嗯，如果我们对 p 取模，那么，gx 等于 g 的这一部分，对吧？嗯，如果我们对 p 取模，

170
00:31:23,200 --> 00:31:33,360
mod p, according to the Fermat's theorem, we know that g to the t times p mass one is congruent to

170
00:31:23,200 --> 00:31:33,360
根据费马定理，我们知道 g 的 t 次方与 p 的质数同余，即..

171
00:31:33,360 --> 00:31:47,039
one mod p, because p is a prime number. This is a Fermat's theorem. So this part can be removed.

171
00:31:33,360 --> 00:31:47,039
因为 p 是质数，所以存在一个模 p 的性质。这属于费马定理的内容。因此，这一部分可以删去。

172
00:31:47,039 --> 00:31:58,960
And thus we have g to the x equals ks from here, xr from here.

172
00:31:47,039 --> 00:31:58,960
因此，我们从这里得到 g 到 x 等于 ks，从这里得到 xr。 (此处已为自然、易懂的中文表达，无需进一步修改)

173
00:32:06,720 --> 00:32:07,279
Is that clear?

173
00:32:06,720 --> 00:32:07,279
那个意思明白吗？

174
00:32:07,279 --> 00:32:24,240
Why we have gx equals gxr plus ks? Because start from the second s generation, second equation.

174
00:32:07,279 --> 00:32:24,240
为什么 gx 等于 gxr 加 ks？因为从第二代开始，第二个方程。

175
00:32:37,279 --> 00:32:54,399
So from this s, so this explains the whole process again. From this s, this equation, right?

175
00:32:37,279 --> 00:32:54,399
因此从这个 s 出发，这又解释了整个过程。这个方程，没错吧？

176
00:32:55,599 --> 00:33:04,559
Here, at both sides, we times k, that means we move the k mass one to the left hand side.

176
00:32:55,599 --> 00:33:04,559
在这里，我们两边都乘以 k，也就是说，我们将 k 质量向左移动一个单位。

177
00:33:05,519 --> 00:33:16,879
So we have ks is congruent to x minus xr mod p minus one. The congruent means this x minus x r

177
00:33:05,519 --> 00:33:16,879
因此，我们有 ks 等于 x 减去 xr 模 p 减一的等价。这里的等价表示 x 减去 xr

178
00:33:16,879 --> 00:33:24,639
can be represented as ks plus t times p minus one, because we have mod p minus one, this operation.

178
00:33:16,879 --> 00:33:24,639
可以表示为 ks 加上 t 乘以 p 减一，因为这里我们有模 p 减一的操作。这种表达方式更为自然和易于理解。

179
00:33:25,440 --> 00:33:34,480
Then this x, the capital X equals k times s plus xr plus t times p minus one.

179
00:33:25,440 --> 00:33:34,480
那么，这个 x，大写 X 等于 k 乘以 s 加上 xr，再加上 t 乘以 p 减一。

180
00:33:38,400 --> 00:33:49,440
And thus we have the result here, the gx equals g to the xr plus ks. And this is in the exponent,

180
00:33:38,400 --> 00:33:49,440
因此，我们在这里得到了结果：gx 等于 g 的 xr 加 ks，这个关系位于指数位置上。

181
00:33:49,600 --> 00:33:55,120
we have addition, that can be translated to the multiplication, because this is the exponential

181
00:33:49,600 --> 00:33:55,120
我们有加法，可以翻译为乘法，因为这是指数运算

182
00:33:55,120 --> 00:34:07,920
operation. So this equals g to the xr times g to the ks. g to the x equals y. This is the small x,

182
00:33:55,120 --> 00:34:07,920
操作。所以这等于 g 的 xr 次方乘以 g 的 ks 次方。g 的 x 次方等于 y。这是小 x，翻译得更加自然和易懂。

183
00:34:08,240 --> 00:34:16,079
equals y. This is the small x, private key. So g to the x equals y.

183
00:34:08,240 --> 00:34:16,079
等于 y。这是小 x 的私钥，所以 g 的 x 次方等于 y。

184
00:34:18,960 --> 00:34:28,480
And g to the k, k is the one time private key. Well, this equals r.

184
00:34:18,960 --> 00:34:28,480
g 映射到 k，k 是单次使用的私钥。嗯，这等于 r。

185
00:34:29,440 --> 00:34:40,240
We can see from the first signature generation, g to the k equals r. And thus we have y to the r,

185
00:34:29,440 --> 00:34:40,240
从第一次签名生成中可以看出，g 到 k 等于 r。因此，我们得到 y 的 r 次方，

186
00:34:41,360 --> 00:34:50,639
y is the public key of Alice. So Bob can use Alice public key, and this r is the signed

186
00:34:41,360 --> 00:34:50,639
y 是爱丽丝的公钥。因此，鲍勃可以使用爱丽丝的公钥，而 r 是签名的值

187
00:34:51,599 --> 00:35:02,159
signature. And r to the s, s is another signed signature. And p is a public key. And thus Bob

187
00:34:51,599 --> 00:35:02,159
签名。并且从 r 到 s，s 是另一个已签名的签名。p 是一个公钥。因此，鲍勃

188
00:35:02,159 --> 00:35:14,400
can verify gx, capital X, equals y to the r times r to the s. If they're equal, that means the message

188
00:35:02,159 --> 00:35:14,400
可以验证 gx，大写 X 等于 y 的 r 次方乘以 r 的 s 次方。如果它们相等，那么说明这条信息

189
00:35:15,119 --> 00:35:22,639
is signed by Alice. So we have the mathematical

189
00:35:15,119 --> 00:35:22,639
由 Alice 签署。因此，我们有数学上的内容

190
00:35:25,280 --> 00:35:38,400
the equations, derivation to guarantee. Well, this result is correct to show the signature is

190
00:35:25,280 --> 00:35:38,400
这些方程及其推导的正确性得到了保证。嗯，这个结果正确地展示了签名是

191
00:35:38,400 --> 00:35:47,519
really generated by Alice, because I'm using Alice, the public key here, to do the verification.

191
00:35:38,400 --> 00:35:47,519
确实是由 Alice 生成的，因为我正在使用 Alice 公钥进行验证，所以这样做。

192
00:35:52,160 --> 00:35:56,800
Okay, let's look at one example. So in this example,

192
00:35:52,160 --> 00:35:56,800
好的，让我们来看一个例子。那么在这个例子中，

193
00:35:56,800 --> 00:36:04,400
so the public key is 11, p is 11, the base g generator is 2,

193
00:35:56,800 --> 00:36:04,400
公钥为 11，p 值为 11，基 g 生成元为 2，

194
00:36:05,920 --> 00:36:13,280
well, 2 is the generator of z11. And public key is, the private key is 3. So public key is

194
00:36:05,920 --> 00:36:13,280
嗯，2 是 z11 的生成器，公钥是，私钥是 3。因此，公钥是

195
00:36:13,680 --> 00:36:21,840
And public key is, the private key is 3. So public key is g to the x, 3,

195
00:36:13,680 --> 00:36:21,840
公钥是，私钥为 3。因此，公钥表示为 g 的 x 次方乘以 3，

196
00:36:23,760 --> 00:36:35,760
g to the x, that is 2 to the 3 mod 11. That's 8. Suppose the message value is 9, and we choose

196
00:36:23,760 --> 00:36:35,760
g 到 x，即 2 的三次方对 11 取模，结果是 8。假设消息值为 9，我们选取

197
00:36:36,480 --> 00:36:50,000
the one time key k to be 7. So k, 7, and p minus 1, 10, the relative prime, and we can get k

197
00:36:36,480 --> 00:36:50,000
一次密钥 k 设为 7。因为 k、7 和 p-1（即 10）互质，所以我们可以求出 k

198
00:36:50,720 --> 00:37:01,200
minus 1. So k minus 1, in this example, I tell you the result is 3. And we calculate the signature

198
00:36:50,720 --> 00:37:01,200
减去 1。在这个例子中，结果是 3，我们再来计算一下签名

199
00:37:01,199 --> 00:37:09,839
r to be g to the k. So base is 2 to the 3, 2 to the k is 7.

199
00:37:01,199 --> 00:37:09,839
r 到 g 到 k。基数是 2 的三次方，2 的 k 次方等于 7。

200
00:37:09,840 --> 00:37:33,280
The mod p mod 11, the result here is 7. So s will be a value to be k minus 1

200
00:37:09,840 --> 00:37:33,280
模 p 模 11 的结果是 7，因此 s 将是 k 减 1 的值

201
00:37:34,240 --> 00:37:43,200
times the message minus the private key x times r mod p minus 1.

201
00:37:34,240 --> 00:37:43,200
消息乘以私钥 x 乘以 r 模 p 减 1 后，再减去 1。

202
00:37:45,840 --> 00:37:59,040
And the value should be, this is 3 times the message is 9, the private key is 3, r is 7,

202
00:37:45,840 --> 00:37:59,040
值应该是，这是消息的 3 倍，即 9，私钥为 3，r 为 7，

203
00:38:00,000 --> 00:38:08,480
and this result is 3 times

203
00:38:00,000 --> 00:38:08,480
这个结果增加了 3 倍

204
00:38:11,199 --> 00:38:12,639
minus 12.

204
00:38:11,199 --> 00:38:12,639
减去 12 点。

205
00:38:17,920 --> 00:38:26,559
So this equals minus 36. This is congruent to 4 because we mod 10.

205
00:38:17,920 --> 00:38:26,559
因此等于负 36，由于我们对 10 取模，所以与 4 同余。这句话更自然、易懂。

206
00:38:26,719 --> 00:38:40,159
And thus the sign message should be, well, the message is 9, with r to be 7, and s to be 4.

206
00:38:26,719 --> 00:38:40,159
因此，签名消息应该是这样的：嗯，信息为 9，r 值为 7，s 值为 4。

207
00:38:45,679 --> 00:38:50,880
In the verification, we compare these two data. The first one is gx.

207
00:38:45,679 --> 00:38:50,880
在验证过程中，我们对比这两份数据，其中第一份数据为 gx。

208
00:38:50,880 --> 00:39:06,160
The first one is gx. g, the base is 2, message is 9, mod p, p is 11, and this result is 6.

208
00:38:50,880 --> 00:39:06,160
第一个数是 gx.g，底数为 2，信息为 9，模 11，结果是 6。

209
00:39:07,119 --> 00:39:18,879
y is the public key, is 8 from here, y is here. r is, this is r, this is s.

209
00:39:07,119 --> 00:39:18,879
y 是公钥，从这里开始是 8 位，这里也是 y。这是 r，这是 s。

210
00:39:19,680 --> 00:39:31,599
So r is 7 times, 7 to the s is 4, mod 11. This result is also 6.

210
00:39:19,680 --> 00:39:31,599
r 是 7 的倍数，7 的 s 次幂等于 4，对 11 取模后结果为 6。

211
00:39:32,400 --> 00:39:38,720
The equal, that means the signature is correct.

211
00:39:32,400 --> 00:39:38,720
这意味着签名正确，即相等。

212
00:39:48,880 --> 00:40:02,720
Any question?

212
00:39:48,880 --> 00:40:02,720
任何问题？

213
00:40:02,719 --> 00:40:18,079
Okay, in part three, we talk about another signature, and this one is quite important.

213
00:40:02,719 --> 00:40:18,079
好的，在第三部分，我们讨论了另一个非常重要的标志性事件。

214
00:40:19,039 --> 00:40:25,679
This is called the bland signature. In some cases, we need to have the bland signature,

214
00:40:19,039 --> 00:40:25,679
这被称为平淡的签名。在某些情况下，我们则需要保留这种平淡的签名，

215
00:40:26,399 --> 00:40:35,279
and we look at what's meaning for bland signature. The basic idea is that a sender

215
00:40:26,399 --> 00:40:35,279
我们来看看“平淡签名”的含义。基本想法是，发送者的

216
00:40:36,399 --> 00:40:45,199
makes a sender to send message m without knowing m. Therefore, blandly,

216
00:40:36,399 --> 00:40:45,199
使得发送者发送消息 m 却不知情。因此，简单地说，

217
00:40:46,319 --> 00:40:49,440
this is needed in some e-commerce applications.

217
00:40:46,319 --> 00:40:49,440
这在一些电子商务应用中是必要的。

218
00:40:50,400 --> 00:40:58,320
In another application, just like in the voting scenario, what's your vote?

218
00:40:50,400 --> 00:40:58,320
在另一个应用程序中，就像在投票场景中一样，你会怎么投票？

219
00:40:59,280 --> 00:41:08,960
You don't want to disclose your voting result to some officer. The officer needs to sign his

219
00:40:59,280 --> 00:41:08,960
你不想向某些官员透露你的投票结果，官员需要签字确认。

220
00:41:09,920 --> 00:41:19,840
signature on your form. So this is another case. Well, when you guarantee that, well,

220
00:41:09,920 --> 00:41:19,840
您表单上的签名。这又是一个案例。嗯，当您确保这一点时，嗯，

221
00:41:19,840 --> 00:41:28,159
the form contains the correct signature from the officer. However, the officer will not know

221
00:41:19,840 --> 00:41:28,159
表单中包含了官员的正确签名，但官员可能不会意识到这一点。

222
00:41:28,879 --> 00:41:33,839
your voting form, your voted result.

222
00:41:28,879 --> 00:41:33,839
你的投票表格，你的投票结果。

223
00:41:36,239 --> 00:41:45,519
So this is a bland signature, just like, well, this is a scenario. Someone can sign

223
00:41:36,239 --> 00:41:45,519
这只是一个平淡无奇的签名，就像，嗯，这是一个场景。任何人都可以签字

224
00:41:46,239 --> 00:41:52,480
the signature. Well, in this hard copy, that's fine.

224
00:41:46,239 --> 00:41:52,480
这就是签名。嗯，在这份纸质副本里，这样挺好的。

225
00:41:53,280 --> 00:42:01,760
Bland, her eyes will not see your content, but can generate the signature. And we won't have

225
00:41:53,280 --> 00:42:01,760
平淡无奇，她的目光无法洞察你的内容，却能生成签名。而且我们也不会

226
00:42:03,039 --> 00:42:07,840
the same process in the e-commerce in two parties.

226
00:42:03,039 --> 00:42:07,840
电子商务中双方遵循的相同流程，表述更为自然流畅。

227
00:42:12,320 --> 00:42:18,159
So bland signature can be generated in the following procedures.

227
00:42:12,320 --> 00:42:18,159
可以按照以下步骤生成如此平淡的签名（使翻译更加自然和易懂）。

228
00:42:19,119 --> 00:42:28,239
So we assume that, well, the original message is m. Of course, we sent something different

228
00:42:19,119 --> 00:42:28,239
我们假设，嗯，原始信息是 m。当然，我们发送了不同的内容，这里更自然、更易于理解的说法是：我们假设原始信息是 m，但当然，我们发送了不同的内容。

229
00:42:29,119 --> 00:42:37,119
to the sender, right? So it cannot be m. That means from m, we generate m prime.

229
00:42:29,119 --> 00:42:37,119
给发件人，对吗？所以不能是 m。这意味着从 m 生成 m'。

230
00:42:37,119 --> 00:42:48,799
m prime is different. So m prime will not disclose your data information.

230
00:42:37,119 --> 00:42:48,799
m prime 与 m 不同，所以不会泄露您的数据信息。

231
00:42:51,440 --> 00:42:58,960
m cannot be obtained by the sender, and m prime will be signed by sender. So sender will sign

231
00:42:51,440 --> 00:42:58,960
m 无法由发送者获取，m'将由发送者进行签名。因此，发送者将进行签名操作。

232
00:42:59,519 --> 00:43:05,199
m prime to get a signature s prime. So for m prime,

232
00:42:59,519 --> 00:43:05,199
m' 获取签名 s'。因此对于 m'，所以...

233
00:43:06,880 --> 00:43:15,280
we'll assume that we are using the RSA algorithm. So m prime to get signature s prime.

233
00:43:06,880 --> 00:43:15,280
我们假设正在使用 RSA 算法。因此，m 是素数，以获取签名 s。

234
00:43:17,519 --> 00:43:24,559
To generate signature, that means we will use the private key to generate the signature.

234
00:43:17,519 --> 00:43:24,559
生成签名，即使用私钥进行签名操作。

235
00:43:25,519 --> 00:43:31,360
D mod n, we have the signature. But

235
00:43:25,519 --> 00:43:31,360
D mod n，我们得到了特征值，但是

236
00:43:33,920 --> 00:43:40,079
in the RSA, suppose in the RSA, this signature generation algorithm,

236
00:43:33,920 --> 00:43:40,079
在 RSA 中，假设我们讨论的是这个签名生成算法，

237
00:43:41,440 --> 00:43:48,079
the message, I'm using my private key, we generate the signature s prime.

237
00:43:41,440 --> 00:43:48,079
消息是：我正在使用我的私钥，我们生成了 s'签名。

238
00:43:48,480 --> 00:43:57,199
Okay, this s prime will be returned to the sender. So sender now can compute the sender's

238
00:43:48,480 --> 00:43:57,199
好的，这个质数将退还给发送方。因此，发送方现在可以计算发送方的信息了。

239
00:43:57,199 --> 00:44:10,239
signature s of m. That means at the sender side, sender will try to generate s from s prime.

239
00:43:57,199 --> 00:44:10,239
签名 s 的 m。也就是说，在发送方，发送者将尝试从 s 原始值生成 s。

240
00:44:10,719 --> 00:44:19,599
This is the arm blinding procedure. So this is called the blinding procedure.

240
00:44:10,719 --> 00:44:19,599
这是手臂失明操作。所以，我们称之为失明程序。

241
00:44:19,599 --> 00:44:41,679
Now this is the arm blinding procedure. And this s, well, the generation s should equal

241
00:44:19,599 --> 00:44:41,679
现在是手臂失明程序。嗯，这个生成器的值应该是

242
00:44:41,759 --> 00:45:00,799
m to the d mod n equals s. We need to guarantee s. Okay, this s contains to be the correct

242
00:44:41,759 --> 00:45:00,799
m 除以 d 模 n 等于 s。我们必须确保 s 是正确的。好的，这个 s 应该包含正确的部分

243
00:45:00,880 --> 00:45:11,920
signal from the sender. That means it equals the m to the d mod n. So d is the private key of the

243
00:45:00,880 --> 00:45:11,920
发送者的信号。这意味着它等于 m 模 n 的 d。因此，d 是私钥。

244
00:45:11,920 --> 00:45:23,200
sender. So it looks to be quite just like a magic, magical trick, right? I do not have your

244
00:45:11,920 --> 00:45:23,200
发送者说，这看起来就像一个神奇的魔术，对吧？我没有你的信息

245
00:45:23,199 --> 00:45:33,919
private key, but somehow I will generate this s. It contains, it equals the message m

245
00:45:23,199 --> 00:45:33,919
私钥，但不知为何我会生成这个 s。它包含的内容，等同于消息 m

246
00:45:34,639 --> 00:45:42,559
to the d mod n. d is the sender's private key. I don't have it, but I can generate the s.

246
00:45:34,639 --> 00:45:42,559
到 d 模 n。d 是发送者的私钥。我没有，但我可以生成 s。

247
00:45:43,199 --> 00:45:56,320
The process can be viewed in this diagram. Well, this is Alice and this is Bob. Alice is the sender.

247
00:45:43,199 --> 00:45:56,320
该过程可在此图中查看。嗯，这是爱丽丝，这是鲍勃。爱丽丝是发送方。这样的表述更符合中文习惯。

248
00:46:00,559 --> 00:46:02,639
Bob is the sender.

248
00:46:00,559 --> 00:46:02,639
Bob 是信息的发送者。

249
00:46:02,639 --> 00:46:13,359
So what we've done in this process is, in the blinding process, we will multiply m with another

249
00:46:02,639 --> 00:46:13,359
在这个过程中，我们做了这样一件事：在盲法阶段，我们会将 m 与另一个数相乘

250
00:46:13,440 --> 00:46:29,840
key. In the blinding process, in the blinding process, we will multiply m with another data.

250
00:46:13,440 --> 00:46:29,840
在遮蔽过程中，我们会将 m 与另一份数据相乘。

251
00:46:30,559 --> 00:46:33,680
And this data r is called the one-time key.

251
00:46:30,559 --> 00:46:33,680
这组数据被称为一次性密钥，意思是指仅使用一次的密钥。

252
00:46:33,919 --> 00:46:48,879
r is a one-time key, random key. So this r, we will, in fact, Alice will choose the data r. r to be

252
00:46:33,919 --> 00:46:48,879
r 是一个一次性随机密钥。实际上，Alice 会选择数据 r。

253
00:46:48,879 --> 00:46:56,079
one-time key. And m will times r to the e, and then mod p.

253
00:46:48,879 --> 00:46:56,079
一次性密钥。将 m 乘以 r 的 e 次方，然后对 p 取模。这句话经过调整，使其在简体中文中更加自然易懂。

254
00:46:57,039 --> 00:47:06,799
And m will times r to the e, and then mod p. So this m prime will be sent to Bob.

254
00:46:57,039 --> 00:47:06,799
然后将 m 乘以 r 的 e 次方，再对 p 取模。这样得到的 m' 将被发送给 Bob。

255
00:47:09,199 --> 00:47:19,440
Alice will choose this r. This r is unknown to Bob. And in this way, m prime will

255
00:47:09,199 --> 00:47:19,440
爱丽丝将选择这个 r。这个 r 对鲍勃来说是未知的。这样，m 的质数就会是

256
00:47:20,400 --> 00:47:26,559
can conceal the original message m. Is this right?

256
00:47:20,400 --> 00:47:26,559
可以隐藏原始信息 m，这样做是否正确？

257
00:47:30,000 --> 00:47:35,760
The m prime will be sent to Bob. This message contains some random number r.

257
00:47:30,000 --> 00:47:35,760
m'将被发送给鲍勃。此消息包含一个随机数 r。

258
00:47:37,119 --> 00:47:45,599
Bob has no idea about r. Thus, Bob cannot get any information from m.

258
00:47:37,119 --> 00:47:45,599
没有关于 r 的了解，因此 Bob 无法从 m 中获取任何信息。

259
00:47:46,480 --> 00:47:55,839
So Bob will do this signing process. The signing is quite simple to Bob. So Bob will apply his

259
00:47:46,480 --> 00:47:55,839
所以鲍勃将执行这个签字流程。对鲍勃来说，这个过程很简单。因此，鲍勃将执行他的

260
00:47:55,839 --> 00:48:06,559
private key d to sign to generate the signature s prime. The s prime will be returned to Alice.

260
00:47:55,839 --> 00:48:06,559
私钥 d 用于生成签名 s'，该签名将返回给 Alice。

261
00:48:06,639 --> 00:48:18,799
So let's see, s prime equals m prime to the d mod p. So m prime equals m times r e,

261
00:48:06,639 --> 00:48:18,799
好吧，让我们看看，s' 等于 m' 的 d 模 p。因此，m' 等于 m 乘以 r 的 e，这样的表述更为自然和易懂。

262
00:48:20,480 --> 00:48:34,559
this to the d mod p. This equals m to the d times r mod p.

262
00:48:20,480 --> 00:48:34,559
这等于 m 的 d 次方模 p。

263
00:48:37,119 --> 00:48:40,960
To the e d mod p.

263
00:48:37,119 --> 00:48:40,960
到 e d 模 p。

264
00:48:44,159 --> 00:48:50,799
Right? Well, according to RSA algorithm, RSA, we know that

264
00:48:44,159 --> 00:48:50,799
嗯？好吧，根据 RSA 算法，我们了解到

265
00:48:52,239 --> 00:49:04,719
r to the e d is congruent to 1 mod p, or previously with mod n. But here we simply use p.

265
00:48:52,239 --> 00:49:04,719
r 到 e d 同余于 1 模 p，之前用模 n 表示。但在此处，我们直接使用 p。

266
00:49:05,359 --> 00:49:06,399
That's the same thing, right?

266
00:49:05,359 --> 00:49:06,399
这不是同一个问题吗？

267
00:49:09,839 --> 00:49:17,839
So you can refresh your memory. m to the e d is congruent to n mod n.

267
00:49:09,839 --> 00:49:17,839
你可以回忆一下，m 的 e 次方 d 与 n 模 n 同余。

268
00:49:20,559 --> 00:49:29,839
And we apply the public key e, apply the private key d again. We can get the original message m

268
00:49:20,559 --> 00:49:29,839
我们首先使用公钥 e 进行加密，然后使用私钥 d 进行解密，从而恢复出原始信息 m

269
00:49:30,800 --> 00:49:42,880
in the RSA algorithm. So here, the r e d will get back to r, that one time key again,

269
00:49:30,800 --> 00:49:42,880
在 RSA 算法中。因此，这里的红色会回到 r，即那个一次性密钥。

270
00:49:44,000 --> 00:49:56,160
1 mod p. So this one will generate, this one equals m d times r mod p.

270
00:49:44,000 --> 00:49:56,160
1 模 p。因此，这个会生成，即等于 m 乘以 d 再模 p 的结果。

271
00:49:56,159 --> 00:50:02,079
So this is the s prime. Is that clear?

271
00:49:56,159 --> 00:50:02,079
这就是 s 的质数。您明白了吗？

272
00:50:05,440 --> 00:50:09,679
Okay, this s prime will be obtained by Alice.

272
00:50:05,440 --> 00:50:09,679
好的，这个素数将由 Alice 得到。

273
00:50:12,000 --> 00:50:22,319
So Alice got s prime. From s prime, Alice will divide this s prime by r

273
00:50:12,000 --> 00:50:22,319
因此，爱丽丝得到了 s 的质数。然后，她将这个质数 s 除以 r

274
00:50:26,799 --> 00:50:42,319
So she will get m to the d times r divided by r mod p. And this equals m d mod p.

274
00:50:26,799 --> 00:50:42,319
因此，她将得到 m 乘以 d 除以 r 再除以 r 模 p。这等于 m 除以 p 的 d 次方余数。

275
00:50:45,599 --> 00:50:52,399
s prime divided by r equals s prime times r minus 1.

275
00:50:45,599 --> 00:50:52,399
s 倍数除以 r 等于 s 倍数乘以 r 减 1（更自然地表达）。

276
00:50:52,400 --> 00:50:58,320
The times r minus 1, that's a module inverse.

276
00:50:52,400 --> 00:50:58,320
时间是 r 减 1，那是一个模逆。这个表达更自然，易于理解。

277
00:51:04,240 --> 00:51:13,680
So you see, s prime times r equals s prime times r minus 1.

277
00:51:04,240 --> 00:51:13,680
你看，s'乘以 r 等于 s'乘以 r 减 1。

278
00:51:14,480 --> 00:51:29,599
Not because if both sides, we times r, we times r, we mod p, of course this can be canceled, right?

278
00:51:14,480 --> 00:51:29,599
因为如果两边都乘以 r，再乘以 r，然后对 p 取模，自然可以约掉，对吧？

279
00:51:29,599 --> 00:51:40,079
This is prime. And according to definition, r minus 1 times r, this is 1 mod p.

279
00:51:29,599 --> 00:51:40,079
这是素数。根据定义，r 减 1 乘以 r，等于 1 模 p。

280
00:51:44,079 --> 00:51:54,559
So of course, with this s prime divided by r, in fact equals s prime times r minus 1.

280
00:51:44,079 --> 00:51:54,559
当然，用这个 s'除以 r，实际上等于 s'乘以 r 减 1。这样的表达更符合中文的表达习惯。

281
00:51:54,559 --> 00:52:00,559
r minus 1 is a module inverse. So how can we do the division operation?

281
00:51:54,559 --> 00:52:00,559
r 减 1 是模逆，那么我们该如何进行除法操作呢？

282
00:52:01,759 --> 00:52:07,199
Division can be translated to the multiplication of the modular inverse.

282
00:52:01,759 --> 00:52:07,199
除法可以理解为模逆乘积的表示。

283
00:52:07,919 --> 00:52:14,159
Okay, so in nature 2, we studied the modular inverse.

283
00:52:07,919 --> 00:52:14,159
好的，那么在自然 2 中，我们学习了模逆的概念。

284
00:52:15,279 --> 00:52:21,599
We just guarantee modular inverse times the r mod p equals 1. That's a requirement.

284
00:52:15,279 --> 00:52:21,599
我们确保模逆乘以 r 模 p 等于 1，这是必须满足的条件。

285
00:52:21,599 --> 00:52:36,960
The eyes can get s prime from Bob. So eyes will divide s prime by r.

285
00:52:21,599 --> 00:52:36,960
眼睛能从 Bob 那里获得 s prime，因此会将 s prime 除以 r。

286
00:52:36,960 --> 00:52:44,719
Or we say s prime times r to the minus 1. Then we can get this is s.

286
00:52:36,960 --> 00:52:44,719
我们说 s 倍的 r 的负一次方，那么就可以得到这是 s。

287
00:52:44,799 --> 00:52:56,879
For message m, it's signature to be signed by Bob. This signature is m to the d mod p.

287
00:52:44,799 --> 00:52:56,879
对于消息 m，其签名应由 Bob 签署。该签名是 m 对 p 取模后的结果。

288
00:52:57,519 --> 00:53:16,000
So this for Bob, the public key is e p. This is the public key. And private key

288
00:52:57,519 --> 00:53:16,000
这是对 Bob 的，公钥是 e p。这是公钥。私钥

289
00:53:16,000 --> 00:53:33,280
is d, right? For Bob. Then you can see this is indeed

289
00:53:16,000 --> 00:53:33,280
是的，对 Bob 来说没错。然后你可以看到这确实是对的

290
00:53:36,239 --> 00:53:43,199
is generated by using Bob's private key based on the original message m.

290
00:53:36,239 --> 00:53:43,199
该内容是通过使用基于原始消息 m 的 Bob 的私钥生成的。翻译更加自然，易于理解。

291
00:53:43,279 --> 00:53:51,759
We have this signature. Although Alice has no idea of Bob's private key,

291
00:53:43,279 --> 00:53:51,759
我们有这个签名。尽管爱丽丝对鲍勃的私钥一无所知，

292
00:53:52,319 --> 00:54:01,359
but she can successfully generate the signature s. In this signing process,

292
00:53:52,319 --> 00:54:01,359
但是她能够成功生成签名 s。在签名过程中，

293
00:54:01,359 --> 00:54:11,119
Bob has no idea of the original message m. So eyes can know this r.

293
00:54:01,359 --> 00:54:11,119
没有了解原始信息 m，因此眼睛可以看出这个 r。

294
00:54:13,519 --> 00:54:25,839
Of course, eyes can calculate r minus 1. When eyes obtain s prime from Bob,

294
00:54:13,519 --> 00:54:25,839
当然，眼睛可以计算出 r 减 1。当眼睛从 Bob 那里得到 s' 后，

295
00:54:26,639 --> 00:54:35,119
so eyes can calculate s prime times r minus 1 mod p, then this equals the signature s.

295
00:54:26,639 --> 00:54:35,119
可以计算 s 的素数倍减 1 模 p，那么这个结果就是签名 s（使翻译更自然、易懂）。

296
00:54:35,119 --> 00:54:50,639
So this is the blind signature generation process.

296
00:54:35,119 --> 00:54:50,639
这就是盲签名生成过程的描述。

297
00:54:50,639 --> 00:55:14,159
We have the charms plus signature scheme. This scheme is exactly the process illustrated in this page.

297
00:54:50,639 --> 00:55:14,159
我们拥有魅力加签名方案。这正是本页所展示的过程，翻译更加自然易懂。

298
00:55:21,440 --> 00:55:32,559
So you can see in this transplant signature, we assume that we're using the RSA algorithm.

298
00:55:21,440 --> 00:55:32,559
因此，您可以从这次移植签名中看出，我们假定使用了 RSA 算法。

299
00:55:33,519 --> 00:55:44,480
And suppose Bob's public key is n and e. His private key is d. The message is m.

299
00:55:33,519 --> 00:55:44,480
假设鲍勃的公钥为 n 和 e，私钥为 d，信息为 m。

300
00:55:44,480 --> 00:55:50,639
m should be smaller than n. And Alice chooses a one-time key k.

300
00:55:44,480 --> 00:55:50,639
m 应该小于 n，Alice 选择一个一次性密钥 k。

301
00:55:51,760 --> 00:55:58,719
k should be in the range from 0 to n. We will guarantee that gcd n k is 1.

301
00:55:51,760 --> 00:55:58,719
k 应该位于 0 到 n 的区间内。我们保证 n 和 k 的最大公约数为 1。

302
00:55:59,679 --> 00:56:06,159
So this will guarantee that we have the k must 1 mod n.

302
00:55:59,679 --> 00:56:06,159
这将确保我们拥有满足 1 模 n 的 k。

303
00:56:06,159 --> 00:56:13,039
k is a randomly chosen number. This is called the blinding factor.

303
00:56:06,159 --> 00:56:13,039
k 是一个随机选取的数字，被称为盲化因子。

304
00:56:16,799 --> 00:56:27,199
In the blinding process, Alice will compute n times k to the e. Alice knows k.

304
00:56:16,799 --> 00:56:27,199
在曝光过程中，Alice 需要计算 n 次 k 的 e 次方。她已知 k 的值。

305
00:56:27,279 --> 00:56:37,279
And in this blinding process, well, when Bob applied his signature, applied his private key d,

305
00:56:27,279 --> 00:56:37,279
在这个令人眼花缭乱的流程中，鲍勃应用了他的签名和私钥 d，嗯，是这样的

306
00:56:37,519 --> 00:56:51,120
and this m prime d equals this one.

306
00:56:37,519 --> 00:56:51,120
这 m 的导数等于这个（更自然的翻译）。

307
00:56:53,440 --> 00:56:59,840
m to the d times k times e d.

307
00:56:53,440 --> 00:56:59,840
m 乘以 d，再乘以 k，最后是 e 的 d 次方。这样的表达更符合中文习惯。

308
00:57:00,160 --> 00:57:11,200
Well, in this way, the random number k with an exponent d can be actually can be cancelled.

308
00:57:00,160 --> 00:57:11,200
嗯，这样就可以实际上取消掉具有指数 d 的随机数 k 了。

309
00:57:11,279 --> 00:57:23,039
We already put the exponent part with a value of e. So e times d mod n. Actually, this equals 1.

309
00:57:11,279 --> 00:57:23,039
我们已经将指数部分赋值为 e，即 e 乘以 d 再对 n 取模。实际上，这个结果等于 1。

310
00:57:24,319 --> 00:57:35,039
So in the on-branded case, we have a random number k with an exponent d.

310
00:57:24,319 --> 00:57:35,039
在品牌未使用的情况下，存在一个随机数 k 和指数 d。

311
00:57:35,759 --> 00:57:45,840
Actually, this equals 1. So in the on-branding, the message we want to get from s prime to s.

311
00:57:35,759 --> 00:57:45,840
实际上，这等于 1。所以在品牌推广中，我们希望从 s'传达给 s 的信息。

312
00:57:46,719 --> 00:57:59,840
So s prime is the signature obtained by Alice. So Alice can get

312
00:57:46,719 --> 00:57:59,840
因此，S'是 Alice 获得的签名。因此，Alice 可以获取到...（此处根据上下文补充具体内容）

313
00:57:59,840 --> 00:58:10,720
s prime times the k must 1. So this will get the original signature.

313
00:57:59,840 --> 00:58:10,720
s 乘以 k 必须等于 1，所以这将获取原始签名。

314
00:58:12,480 --> 00:58:16,640
The reason is because s prime, this is s prime.

314
00:58:12,480 --> 00:58:16,640
原因在于 s 是一个素数，这正是 s 的特性。

315
00:58:16,639 --> 00:58:31,440
So s prime equals m d is equal to m d times k mod n. So from s prime to s,

315
00:58:16,639 --> 00:58:31,440
因此，s' 等于 m d，等于 m d 乘以 k 模 n。从 s' 到 s，

316
00:58:32,400 --> 00:58:39,839
we can simply multiply s prime by k must 1. This will generate the signature s.

316
00:58:32,400 --> 00:58:39,839
我们只需将 s'乘以 k（必须为 1），就能生成签名 s。

317
00:58:47,279 --> 00:59:01,199
So this is the whole process. You can see this is the m prime. m prime to d, we have m d, this is s, this is k.

317
00:58:47,279 --> 00:59:01,199
这就是整个流程。你可以看到这是 m 的导数。从 m 导数到 d，我们有 md，这是 s，这是 k。

318
00:59:01,199 --> 00:59:12,559
You have mod n, e d.

318
00:59:01,199 --> 00:59:12,559
您有模数 n，e d。

319
00:59:14,879 --> 00:59:26,480
In our RSA algorithm, e d, we choose e d such that it equals, it is congruent to 1 mod phi.

319
00:59:14,879 --> 00:59:26,480
在我们的 RSA 算法中，我们选择 e 和 d，使得它们与φ同余 1。这样的选择使得 e 和 d 更加自然且易于理解。

320
00:59:27,199 --> 00:59:35,599
This is a guarantee that k e d mod n equals k.

320
00:59:27,199 --> 00:59:35,599
这是一种保证，即 k 除以 n 的余数等于 k。

321
00:59:39,119 --> 00:59:44,159
So thus, we can get the s. This is the signature.

321
00:59:39,119 --> 00:59:44,159
因此，我们可以得到这个 s。这便是签名。

322
00:59:49,280 --> 00:59:53,599
And this signature equals this part

322
00:59:49,280 --> 00:59:53,599
这个签名等同于这一部分

323
00:59:57,440 --> 00:59:59,599
is s prime.

323
00:59:57,440 --> 00:59:59,599
它是质数吗？

324
01:00:10,800 --> 01:00:18,639
Okay, now we look at this exercise. Suppose we have the copy key to be

324
01:00:10,800 --> 01:00:18,639
好的，现在我们来分析这个练习。假设我们拥有复制键为

325
01:00:18,719 --> 01:00:26,879
e equals 5, n is 1, 1, 9. So 1, 1, 9 equals 7 times 17, right?

325
01:00:18,719 --> 01:00:26,879
e 等于 5，n 分别为 1、1、9，那么 1、1、9 就是 7 乘以 17，对吧？

326
01:00:28,480 --> 01:00:38,480
This p to be 7, q to be 17. The requester wants a signature on the message m equals

326
01:00:28,480 --> 01:00:38,480
这 p 等于 7，q 等于 17。请求者在消息 m 上要求签名。

327
01:00:39,440 --> 01:00:50,320
37. Suppose he chooses a random blending factor R to be 29. So we need to guarantee that g c d

327
01:00:39,440 --> 01:00:50,320
37. 假设他随机选取一个混合因子 R 为 29，因此需要保证 gcd

328
01:00:51,440 --> 01:01:01,039
R n is 1. In this way, we can calculate our must 1 mod n.

328
01:00:51,440 --> 01:01:01,039
Rn 等于 1，这样我们就可以计算 1 对 n 的模了。

329
01:01:01,199 --> 01:01:10,400
So what's the private key of Sonar? We have the public key, e and n. We are able to calculate

329
01:01:01,199 --> 01:01:10,400
那么，Sonar 的私钥是什么？我们已经有了公钥 e 和 n，能够计算出

330
01:01:11,199 --> 01:01:18,320
the Sonar's private key. And then we should apply the blending phase.

330
01:01:11,199 --> 01:01:18,320
这是声纳的私钥，接下来应进行混合处理阶段。

331
01:01:18,720 --> 01:01:28,640
So suppose this step 1, step 2, blending phase, step 3, signing phase, step 4 on blending phase.

331
01:01:18,720 --> 01:01:28,640
假设这一步骤包括 1、2、混合阶段、3、签署阶段、4 在混合阶段。

332
01:01:29,600 --> 01:01:39,600
In the blending phase, that means the message m times R is one time key. We apply the same

332
01:01:29,600 --> 01:01:39,600
在混合阶段，这意味着消息 m 乘以 R 是一次密钥。我们采用相同的处理方式。

333
01:01:39,599 --> 01:01:53,679
message m times R is one time key. We apply the public key of the Sonar, right?

333
01:01:39,599 --> 01:01:53,679
消息 m 次 R 对应一个密钥。我们使用 Sonar 的公钥，对吗？

334
01:01:56,319 --> 01:02:02,960
This is the blending phase. We get m prime. In the signing phase,

334
01:01:56,319 --> 01:02:02,960
这是混合阶段。我们得到 m'。在签名阶段，

335
01:02:02,960 --> 01:02:13,599
this is quite simple. The Sonar will apply his private key to do the signing. That's the m prime

335
01:02:02,960 --> 01:02:13,599
这非常简单。Sonar 会使用其私钥进行签名，这就是 m 的质数

336
01:02:15,199 --> 01:02:26,000
to apply the private key d to generate the s prime. In the on-blending phase, it is

336
01:02:15,199 --> 01:02:26,000
将私钥 d 应用于生成 s'。在混合阶段，它用于...

337
01:02:26,000 --> 01:02:41,119
done by the requester. He will get the signature s from s prime times R one time key,

337
01:02:26,000 --> 01:02:41,119
由请求者完成。他将获得从 s'乘以 R 一次密钥得到的签名，表达更为自然。

338
01:02:42,559 --> 01:02:47,440
the module inverse of this R mod n.

338
01:02:42,559 --> 01:02:47,440
这个 R 模 n 的逆元模块（经过润色）。

339
01:02:47,440 --> 01:02:54,720
OK, so this is an exercise. Let's have a break for 10 minutes. So in 10 minutes,

339
01:02:47,440 --> 01:02:54,720
好的，这是一个练习。那么我们先休息 10 分钟吧。再过 10 分钟，

340
01:02:55,760 --> 01:03:04,480
you can try to solve this exercise. OK, so let's have a break for 10 minutes.

340
01:02:55,760 --> 01:03:04,480
你可以尝试完成这个练习。好的，让我们休息 10 分钟。

