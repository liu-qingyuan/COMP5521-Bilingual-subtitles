1
00:00:00,000 --> 00:00:19,000
Well, wait, it's long.

1
00:00:00,000 --> 00:00:19,000
嗯，等等，这个挺长的。

2
00:00:19,000 --> 00:00:42,000
Okay, it looks like the transcription is turned off for the meeting organizer by organizing policy.

2
00:00:19,000 --> 00:00:42,000
好吧，根据组织政策，会议组织者的转录功能似乎已经关闭了。

3
00:00:42,000 --> 00:00:47,000
Okay, I suppose the recording has no problem.

3
00:00:42,000 --> 00:00:47,000
好吧，我想这录音没问题。

4
00:00:47,000 --> 00:00:58,000
Previously, I can see the transcript to guarantee the recording is on, but today I cannot.

4
00:00:47,000 --> 00:00:58,000
之前我可以通过查看转录本来确认录音是开启的，但今天却做不到这一点了。

5
00:00:58,000 --> 00:01:10,000
So I suppose the recording is on and it can record my voice.

5
00:00:58,000 --> 00:01:10,000
因此我猜录音设备已经开启，能够录下我的声音。

6
00:01:10,000 --> 00:01:19,000
But there's no transcript.

6
00:01:10,000 --> 00:01:19,000
但是没有文字记录，请见谅。

7
00:01:19,000 --> 00:01:25,000
Stop.

7
00:01:19,000 --> 00:01:25,000
停止

8
00:01:25,000 --> 00:01:40,000
Stop.

8
00:01:25,000 --> 00:01:40,000
停止

9
00:01:40,000 --> 00:01:43,000
Turn on.

9
00:01:40,000 --> 00:01:43,000
打开（更自然的表达）

10
00:01:43,000 --> 00:01:45,000
Do it here.

10
00:01:43,000 --> 00:01:45,000
在这里执行。

11
00:01:45,000 --> 00:02:12,000
Start.

11
00:01:45,000 --> 00:02:12,000
开始。

12
00:02:12,000 --> 00:02:16,000
Okay, I suppose the recording is fine, okay?

12
00:02:12,000 --> 00:02:16,000
好吧，我觉得录音应该没问题，对吧？

13
00:02:16,000 --> 00:02:27,000
Because the mic here is on, although I cannot see the transcript.

13
00:02:16,000 --> 00:02:27,000
因为这里的麦克风是开着的，虽然我看不到文稿。

14
00:02:27,000 --> 00:02:32,000
Okay, anyway, the recording isn't on.

14
00:02:27,000 --> 00:02:32,000
好吧，不管怎样，录音没开。

15
00:02:32,000 --> 00:02:36,000
Sure.

15
00:02:32,000 --> 00:02:36,000
当然。

16
00:02:36,000 --> 00:02:51,000
Here is start recording.

16
00:02:36,000 --> 00:02:51,000
这里开始录制。

17
00:02:51,000 --> 00:03:01,000
Start recording.

17
00:02:51,000 --> 00:03:01,000
开始录制。

18
00:03:01,000 --> 00:03:11,000
Okay, so we start.

18
00:03:01,000 --> 00:03:11,000
好吧，那我们就开始了。

19
00:03:11,000 --> 00:03:16,000
Okay, last time we talked about the lecture three about cryptography.

19
00:03:11,000 --> 00:03:16,000
好的，上次我们讨论了关于密码学的第三讲。

20
00:03:16,000 --> 00:03:31,000
So we finished part one about the summation encryption.

20
00:03:16,000 --> 00:03:31,000
我们完成了关于求和加密的第一部分，内容如下：

21
00:03:31,000 --> 00:03:38,000
In summation encryption, we have the idea that both the sender and the receiver, they share the same key, K.

21
00:03:31,000 --> 00:03:38,000
在求和加密中，发送者和接收者共享同一个密钥 K，这一概念被提出。

22
00:03:38,000 --> 00:03:43,000
Key K will be used for both encryption and decryption.

22
00:03:38,000 --> 00:03:43,000
密钥 K 将同时用于加密和解密。

23
00:03:43,000 --> 00:03:48,000
And we have the common null encryption algorithm and decryption algorithm.

23
00:03:43,000 --> 00:03:48,000
我们拥有常见的空加密和解密算法。

24
00:03:48,000 --> 00:03:53,000
Just like in this example, we use AES.

24
00:03:48,000 --> 00:03:53,000
就像在这个例子中，我们使用 AES。这个翻译已经比较自然和易懂了。

25
00:03:53,000 --> 00:03:57,000
Well, in this summation encryption, only the key K will be secret.

25
00:03:53,000 --> 00:03:57,000
嗯，在这种求和加密中，只有密钥 K 是保密的。

26
00:03:57,000 --> 00:04:07,000
Others, like the encryption algorithm and decryption algorithm, will know to everyone.

26
00:03:57,000 --> 00:04:07,000
其他，例如加密和解密算法，大家都会知道。

27
00:04:07,000 --> 00:04:13,000
So this model, and we talked about the SIDA CIFR.

27
00:04:07,000 --> 00:04:13,000
因此，我们讨论了这个模型以及 SIDA 的 CIFR。

28
00:04:13,000 --> 00:04:20,000
So SIDA CIFR is easy to be attacked because we can try all possible cases, right?

28
00:04:13,000 --> 00:04:20,000
SIDA CIFR 非常容易受到攻击，因为我们可以尝试所有可能的情况，对吧？

29
00:04:20,000 --> 00:04:24,000
Just like in this example, we can use a brute force attack.

29
00:04:20,000 --> 00:04:24,000
就像这个例子一样，我们可以使用暴力攻击。

30
00:04:24,000 --> 00:04:32,000
The key K can be tested from 1 to 25.

30
00:04:24,000 --> 00:04:32,000
关键字 K 可以从 1 测试到 25。

31
00:04:32,000 --> 00:04:35,000
Then we talk about the one-time path.

31
00:04:32,000 --> 00:04:35,000
我们再讨论一次性路径（使翻译更自然易懂）。

32
00:04:35,000 --> 00:04:43,000
The one-time path is only null, perfect, secrecy scheme.

32
00:04:35,000 --> 00:04:43,000
一次性路径仅能是空值，这是一个完美的保密方案。

33
00:04:43,000 --> 00:04:50,000
However, one-time path is quite difficult to be applied in the reality, in the real world.

33
00:04:43,000 --> 00:04:50,000
然而，在现实中，一次性路径的应用相当困难。

34
00:04:50,000 --> 00:04:54,000
Because one-time path requires the key length.

34
00:04:50,000 --> 00:04:54,000
因为一次性路径需要指定键的长度。

35
00:04:54,000 --> 00:05:01,000
The key length will be the same as your plaintext.

35
00:04:54,000 --> 00:05:01,000
密钥长度将与您的明文长度一致

36
00:05:01,000 --> 00:05:05,000
In part two, we talked about the public key scheme.

36
00:05:01,000 --> 00:05:05,000
在第二部分，我们讨论了公钥方案。这里所说的公钥方案是指...

37
00:05:05,000 --> 00:05:10,000
Particularly, we talked about the RSA algorithm.

37
00:05:05,000 --> 00:05:10,000
尤其是我们讨论了 RSA 算法。

38
00:05:10,000 --> 00:05:14,000
So in this RSA algorithm, we show the mechanism.

38
00:05:10,000 --> 00:05:14,000
在这个 RSA 算法中，我们展示了其工作原理。

39
00:05:14,000 --> 00:05:17,000
Why do we have the RSA algorithm?

39
00:05:14,000 --> 00:05:17,000
我们为什么会有 RSA 算法呢？

40
00:05:17,000 --> 00:05:26,000
From the Euler's theorem, how we can generate the public key and the private key here.

40
00:05:17,000 --> 00:05:26,000
从欧拉定理出发，我们在这里是如何生成公钥和私钥的。

41
00:05:26,000 --> 00:05:34,000
So according to our previous knowledge in the module inverse Euclidean algorithm,

41
00:05:26,000 --> 00:05:34,000
  

42
00:05:34,000 --> 00:05:46,000
we can derive the public key and private key to make sure that the ED and DNE, the module inverse, mod phi n.

42
00:05:34,000 --> 00:05:46,000
我们可以推导出公钥和私钥，以确保 ED 和 DNE，模逆元，模φn。这样的表述更加自然和易于理解。

43
00:05:46,000 --> 00:05:54,000
So we know what's the meaning for phi n.

43
00:05:46,000 --> 00:05:54,000
我们知道 phi n 的意思是什么

44
00:05:54,000 --> 00:06:03,000
So this is a real example to see how we can, based on the given PQ value, we have the n value.

44
00:05:54,000 --> 00:06:03,000
因此这是一个真实示例，以查看我们如何根据给定的 PQ 值，得到 n 值。这使得翻译更加自然和易于理解。

45
00:06:03,000 --> 00:06:06,000
n is a product of P and Q.

45
00:06:03,000 --> 00:06:06,000
n 是由 P 和 Q 相乘得到的。

46
00:06:06,000 --> 00:06:14,000
And because n is a product of two primes, so phi n equals P minus 1 times Q minus 1.

46
00:06:06,000 --> 00:06:14,000
因为 n 是两个质数的乘积，所以φ(n)等于 P 减 1 与 Q 减 1 的乘积。

47
00:06:14,000 --> 00:06:20,000
Once we know the phi n, and also we know the public key E to be 5 here,

47
00:06:14,000 --> 00:06:20,000
一旦我们知道了 phi n 的值，并且已知这里的公钥 E 为 5，

48
00:06:20,000 --> 00:06:26,000
we are able to calculate the module inverse of E to be D.

48
00:06:20,000 --> 00:06:26,000
我们可以计算出 E 的模逆是 D。

49
00:06:26,000 --> 00:06:31,000
So D is the private key.

49
00:06:26,000 --> 00:06:31,000
因此，D 是私钥。

50
00:06:31,000 --> 00:06:43,000
With public key and private key, we can apply the RSA algorithm to calculate the subtext C from the original message M.

50
00:06:31,000 --> 00:06:43,000
使用公钥和私钥，我们可以通过 RSA 算法从原始消息 M 计算出子文本 C。这样的表述更加自然易懂。

51
00:06:43,000 --> 00:06:48,000
So M to the E mod n is C.

51
00:06:43,000 --> 00:06:48,000
所以 M 到 E 模 n 等于 C。

52
00:06:48,000 --> 00:06:57,000
And from C, we can get back to its original message M to apply C to the D mod n.

52
00:06:48,000 --> 00:06:57,000
从 C 出发，我们可以回到原始消息 M，对 D 模 n 应用 C。这使得翻译更加自然和易于理解。

53
00:06:57,000 --> 00:07:06,000
And also we can see we can use CRT, this theorem, to accelerate our calculation of the big numbers.

53
00:06:57,000 --> 00:07:06,000
我们还可以看到，利用 CRT 定理可以加速大数的计算，这样的表述更为自然易懂。

54
00:07:07,000 --> 00:07:11,000
Their exponential operation mod big number n.

54
00:07:07,000 --> 00:07:11,000
他们的指数运算对大数 n 取模。

55
00:07:11,000 --> 00:07:20,000
So this can allow us to quickly get the result for this mod operation.

55
00:07:11,000 --> 00:07:20,000
这样可以让我们快速得到这个模运算的结果，表达更自然。

56
00:07:20,000 --> 00:07:25,000
In part three, we took about another very important concept.

56
00:07:20,000 --> 00:07:25,000
在第三部分，我们探讨了另一个至关重要的概念。

57
00:07:26,000 --> 00:07:29,000
It is a Diffie-Hellman algorithm.

57
00:07:26,000 --> 00:07:29,000
这是一个迪菲-赫尔曼算法。

58
00:07:29,000 --> 00:07:37,000
So this one will allow two parties to calculate the secret key K.

58
00:07:29,000 --> 00:07:37,000
因此，这将允许双方计算密钥 K，表达更为自然。

59
00:07:37,000 --> 00:07:50,000
So they can share this key K, KKA equals KB, to guarantee that they have the same symmetric key K for the future complications.

59
00:07:37,000 --> 00:07:50,000
因此，他们可以共享这个密钥 K，即 KKA 等于 KB，以确保未来在遇到复杂情况时，他们使用的对称密钥 K 是一致的。

60
00:07:50,000 --> 00:08:01,000
So the security is guaranteed that we took about the discrete log algorithm.

60
00:07:50,000 --> 00:08:01,000
因此，我们讨论了如何确保离散对数算法的安全性。

61
00:08:01,000 --> 00:08:13,000
So in the next lecture, in this exponential operation, just like Alice chooses A, Bob chooses B,

61
00:08:01,000 --> 00:08:13,000
所以在下一节课中，在这个指数运算中，就像爱丽丝选择 A 一样，鲍勃选择 B，

62
00:08:13,000 --> 00:08:19,000
Alice will calculate small x from GA mod P.

62
00:08:13,000 --> 00:08:19,000
爱丽丝将从 GA mod P 中计算出一个小 x 值。

63
00:08:19,000 --> 00:08:23,000
But even this x is sent to anyone else.

63
00:08:19,000 --> 00:08:23,000
即使是这个 x 也会被发送给其他人。

64
00:08:23,000 --> 00:08:28,000
So no one will know the chosen A by Alice.

64
00:08:23,000 --> 00:08:28,000
因此，没有人会知道爱丽丝选了哪个 A。

65
00:08:28,000 --> 00:08:33,000
The reason is because this is a discrete log problem.

65
00:08:28,000 --> 00:08:33,000
原因在于这是一个离散对数问题。

66
00:08:33,000 --> 00:08:36,000
So actually it is very hard.

66
00:08:33,000 --> 00:08:36,000
实际上，这真的很困难。

67
00:08:36,000 --> 00:08:51,000
Without knowing the A, only with the value of x, it is impossible to calculate the small a in this Diffie-Hellman algorithm.

67
00:08:36,000 --> 00:08:51,000
在不知 A 的情况下，仅凭 x 的值，根本无法计算出 Diffie-Hellman 算法中的小 a。

68
00:08:51,000 --> 00:09:09,000
The Diffie-Hellman algorithm will allow two people to get the same symmetric key K to be used in the symmetric encryption.

68
00:08:51,000 --> 00:09:09,000
Diffie-Hellman 算法可以让两个人获得相同的对称密钥 K，该密钥可用于对称加密。这个翻译更加自然和易于理解。

69
00:09:09,000 --> 00:09:13,000
So now we look at part four.

69
00:09:09,000 --> 00:09:13,000
现在让我们看看第四部分。

70
00:09:13,000 --> 00:09:27,000
So part four will provide you some knowledge about the public key cryptography, what's the requirement, and how we can look at their security for the RSA algorithm.

70
00:09:13,000 --> 00:09:27,000
第四部分将为您介绍公钥密码学的基础知识，包括其需求以及如何评估 RSA 算法的安全性。

71
00:09:27,000 --> 00:09:36,000
So for RSA algorithm, its security is guaranteed by the factorization of a big number.

71
00:09:27,000 --> 00:09:36,000
因此，RSA 算法的安全性由一个大数的分解来保证，这一点得到了保障。

72
00:09:36,000 --> 00:09:46,000
To factorize, we say factorization is to factorize n to be the product of P and Q.

72
00:09:36,000 --> 00:09:46,000
因式分解，即把 n 分解成 P 和 Q 的乘积。这样的表述更为自然易懂。

73
00:09:46,000 --> 00:09:56,000
So this process is very difficult, given n to be a very large number, to be like 1024 bits.

73
00:09:46,000 --> 00:09:56,000
因此，这个过程相当复杂，假设 n 是一个非常大的数，例如 1024 位。

74
00:09:56,000 --> 00:10:03,000
If you want to get its corresponding P and Q, that would be very difficult.

74
00:09:56,000 --> 00:10:03,000
如果您想找到它的对应 P 和 Q 值，那将会非常困难。

75
00:10:07,000 --> 00:10:13,000
So suppose n is one of 24 bits.

75
00:10:07,000 --> 00:10:13,000
假设 n 是 24 位中的一个。

76
00:10:13,000 --> 00:10:20,000
What's the size for P and Q?

76
00:10:13,000 --> 00:10:20,000
P 和 Q 的尺寸是多少？

77
00:10:20,000 --> 00:10:25,000
P and Q, the size will be what?

77
00:10:20,000 --> 00:10:25,000
P 和 Q 的大小会是多少？

78
00:10:25,000 --> 00:10:34,000
How many bits for P and Q?

78
00:10:25,000 --> 00:10:34,000
P 和 Q 需要多少位？（更自然、更易理解的翻译）

79
00:10:34,000 --> 00:10:37,000
How many bits for P and Q?

79
00:10:34,000 --> 00:10:37,000
P 和 Q 需要多少位？（更自然、更易理解的翻译）

80
00:10:37,000 --> 00:10:43,000
If we suppose n is 1024 bits.

80
00:10:37,000 --> 00:10:43,000
假定 n 有 1024 位。

81
00:10:43,000 --> 00:10:47,000
Any idea?

81
00:10:43,000 --> 00:10:47,000
任何想法？

82
00:10:47,000 --> 00:10:55,000
If it's 512, should be what?

82
00:10:47,000 --> 00:10:55,000
如果是 512，那应该是哪个？

83
00:10:55,000 --> 00:10:59,000
So P and Q will be similar size to n, right?

83
00:10:55,000 --> 00:10:59,000
所以 P 和 Q 的大小将与 n 相似，没错吧？

84
00:10:59,000 --> 00:11:02,000
Should be similar size.

84
00:10:59,000 --> 00:11:02,000
应该大小相近。

85
00:11:08,000 --> 00:11:17,000
Okay, we look at in the public key cryptography, we have different ways to apply the private key and public key.

85
00:11:08,000 --> 00:11:17,000
好的，在公钥密码学中，我们了解到有多种方法可以用来使用私钥和公钥。

86
00:11:17,000 --> 00:11:26,000
So you can use public key in the encryption, or you can use the private key in the encryption.

86
00:11:17,000 --> 00:11:26,000
您可以选择使用公钥或私钥进行加密。这样的表述更为自然易懂。

87
00:11:26,000 --> 00:11:33,000
So first we look at the first scheme, we use the public key in the encryption.

87
00:11:26,000 --> 00:11:33,000
首先我们来查看第一个方案，加密时使用公钥。

88
00:11:33,000 --> 00:11:39,000
Just like support Bob is the sender and Alice is the receiver.

88
00:11:33,000 --> 00:11:39,000
就像支持一样，Bob 是发送方，Alice 是接收方。

89
00:11:39,000 --> 00:11:44,000
So support Bob wants to send a message n to Alice.

89
00:11:39,000 --> 00:11:44,000
因此，支持 Bob 想给 Alice 发送消息 n。

90
00:11:44,000 --> 00:11:47,000
So this message x.

90
00:11:44,000 --> 00:11:47,000
这条消息是 x。

91
00:11:47,000 --> 00:11:55,000
And well, Bob can use Alice's public key to do the encryption, right, to do the encryption.

91
00:11:47,000 --> 00:11:55,000
嗯，鲍勃可以用爱丽丝的公钥进行加密，对吧？

92
00:11:55,000 --> 00:12:01,000
Then the subtext y will be sent to Alice.

92
00:11:55,000 --> 00:12:01,000
然后将子文本 y 发送给 Alice。 (This is the refined translation, as the initial translation is already natural and understandable.)

93
00:12:01,000 --> 00:12:08,000
So this y is encrypted by using Alice's public key.

93
00:12:01,000 --> 00:12:08,000
因此，这个 y 是通过 Alice 的公钥进行加密的，翻译得更加自然和易懂。

94
00:12:08,000 --> 00:12:16,000
So only Alice has a private key, so other than Alice, no one else can do the decryption.

94
00:12:08,000 --> 00:12:16,000
因此，只有 Alice 拥有私钥，其他人无法进行解密。这样的表述更为自然易懂。

95
00:12:16,000 --> 00:12:24,000
So Alice can use her private key to do the decryption and get back the original message x.

95
00:12:16,000 --> 00:12:24,000
因此，Alice 可以用她的私钥进行解密，恢复原始消息 x。

96
00:12:24,000 --> 00:12:34,000
So this y in the RSA algorithm, we know that the public key is e and n, right?

96
00:12:24,000 --> 00:12:34,000
所以在 RSA 算法中，我们知道公钥是 e 和 n，这个 y 指的是什么？对吧？

97
00:12:34,000 --> 00:12:36,000
And private key is d.

97
00:12:34,000 --> 00:12:36,000
私钥为 d。

98
00:12:36,000 --> 00:12:44,000
So this y equals x to the e mod n.

98
00:12:36,000 --> 00:12:44,000
因此，这个 y 等于 x 的 e 次方对 n 取模。

99
00:12:44,000 --> 00:12:50,000
And to do the decryption, Alice will apply her private key.

99
00:12:44,000 --> 00:12:50,000
为了解密，Alice 将使用她的私钥。这样的表述更加自然易懂。

100
00:12:50,000 --> 00:13:00,000
So to get back x equals the subtext y to the private key d mod n.

100
00:12:50,000 --> 00:13:00,000
因此，要得到 x 等于私钥 d 对 n 取模后的子文本 y。

101
00:13:00,000 --> 00:13:06,000
OK, so this is the encryption and the decryption process.

101
00:13:00,000 --> 00:13:06,000
好的，这就是加密和解密的过程。 （经过润色，使翻译更加自然易懂）

102
00:13:06,000 --> 00:13:15,000
Of course, someone can apply the second case using the private key to do the encryption.

102
00:13:06,000 --> 00:13:15,000
当然，有人可以利用私钥来应用第二种加密方式。

103
00:13:16,000 --> 00:13:21,000
So Bob will use his private key to do the encryption.

103
00:13:16,000 --> 00:13:21,000
因此鲍勃将使用他的私钥进行加密。

104
00:13:21,000 --> 00:13:30,000
So this y equals x to the d mod n, right?

104
00:13:21,000 --> 00:13:30,000
所以这个 y 等于 x 的 d 次方对 n 取模，对吧？

105
00:13:30,000 --> 00:13:36,000
Well, using your private key, you can do decryption.

105
00:13:30,000 --> 00:13:36,000
嗯，用您的私钥，您可以进行解密操作。

106
00:13:36,000 --> 00:13:42,000
But anyone else can use your public key to do the decryption.

106
00:13:36,000 --> 00:13:42,000
但任何人都可以使用您的公钥进行解密，表达更为自然。

107
00:13:42,000 --> 00:13:47,000
Your public key is publicly known by everyone.

107
00:13:42,000 --> 00:13:47,000
您的公钥为公众所知，表述更为自然。

108
00:13:47,000 --> 00:13:52,000
So Alice can use Bob's public key to do the decryption.

108
00:13:47,000 --> 00:13:52,000
因此 Alice 可以使用 Bob 的公钥进行解密。

109
00:13:52,000 --> 00:14:03,000
So Alice can obtain the plaintext by applying y to the e mod n.

109
00:13:52,000 --> 00:14:03,000
因此 Alice 可以通过对 e 模 n 应用 y 来获取明文。

110
00:14:03,000 --> 00:14:13,000
OK, so because, well, you can see this y equals x to the d e mod n.

110
00:14:03,000 --> 00:14:13,000
好吧，所以因为，嗯，你可以看到这个 y 等于 x 的 d 次方除以 n 的余数。

111
00:14:13,000 --> 00:14:19,000
This is x to the e d mod n.

111
00:14:13,000 --> 00:14:19,000
这是 x 的 e 次方除以 n 的余数（更自然地表达）。

112
00:14:19,000 --> 00:14:29,000
So e d, in fact, equals x to the k times 5 plus 1 mod n, right?

112
00:14:19,000 --> 00:14:29,000
事实上，So e d 等于 x 的 k 次方乘以 5 再加 1，然后对 n 取模，对吧？

113
00:14:29,000 --> 00:14:42,000
Because we will choose e d is congruent to 1 mod phi n.

113
00:14:29,000 --> 00:14:42,000
因为我们将选择 e d 与φ n 同余 1，这样表达更为自然易懂。

114
00:14:42,000 --> 00:14:53,000
So according to the Euler's theorem, well, this mod n in the exponent part phi n, this one can be cancelled.

114
00:14:42,000 --> 00:14:53,000
根据欧拉定理，嗯，这个指数部分的模 n 在 n 的欧拉函数中可以约掉，翻译得更加自然易懂。

115
00:14:53,000 --> 00:14:59,000
OK, normally we apply the second scheme to generate the signature.

115
00:14:53,000 --> 00:14:59,000
好的，我们通常采用第二个方案来生成签名。这样的表达更自然、易懂。

116
00:14:59,000 --> 00:15:04,000
Somehow this is not a standard way to generate the signature.

116
00:14:59,000 --> 00:15:04,000
这种生成签名的方法并不符合常规。

117
00:15:04,000 --> 00:15:07,000
But the idea is the same.

117
00:15:04,000 --> 00:15:07,000
但这个想法是相同的。

118
00:15:07,000 --> 00:15:11,000
You will use your private key to generate your signature.

118
00:15:07,000 --> 00:15:11,000
您将使用您的私钥来生成您的签名。（更自然、更易理解的翻译）

119
00:15:11,000 --> 00:15:17,000
And others will use your public key to do the signature verification, right?

119
00:15:11,000 --> 00:15:17,000
其他人会用您的公钥进行签名验证，您觉得对吗？

120
00:15:17,000 --> 00:15:22,000
Because only you have that unique private key.

120
00:15:17,000 --> 00:15:22,000
因为只有你才拥有那个独一无二的私钥。

121
00:15:22,000 --> 00:15:25,000
So others can use your public key to do verification.

121
00:15:22,000 --> 00:15:25,000
以便其他人可以使用您的公钥进行验证，这样更自然易懂。

122
00:15:25,000 --> 00:15:40,000
That message is really from Alice because the receiver is using Alice public key to do the verification.

122
00:15:25,000 --> 00:15:40,000
那条消息确实来自 Alice，因为接收者正在使用 Alice 的公钥进行验证，这一点非常明确。

123
00:15:40,000 --> 00:15:50,000
Well, for the public key crypto systems, well, this can solve two important problems.

123
00:15:40,000 --> 00:15:50,000
好吧，对于公钥加密系统来说，嗯，这可以解决两个关键问题。这样的表述可能更自然、更易于理解。

124
00:15:51,000 --> 00:16:04,000
The concept of public key cryptography evolved from an attempt to solve two of the most difficult problems associated with the symmetric encryption.

124
00:15:51,000 --> 00:16:04,000
公钥密码学的概念起源于尝试解决与对称加密相关的两个最棘手的问题。以下是对该概念的更自然和易于理解的表述：公钥密码学的概念源于尝试解决与对称加密相关的两个最困难的问题。

125
00:16:04,000 --> 00:16:17,000
So that means in symmetric encryption, it is very hard to get key distribution and very hard to generate the digital signatures.

125
00:16:04,000 --> 00:16:17,000
这意味着在对称加密中，密钥分配非常困难，生成数字签名也相当不易。

126
00:16:17,000 --> 00:16:24,000
Well, in the symmetric encryption, both the sender and the receiver, they should have the same key.

126
00:16:17,000 --> 00:16:24,000
在对称加密中，发送方和接收方应使用相同的密钥。

127
00:16:24,000 --> 00:16:29,000
So before they can do encryption, decryption, they should have the same key.

127
00:16:24,000 --> 00:16:29,000
在进行加密和解密操作之前，它们必须使用相同的密钥。

128
00:16:29,000 --> 00:16:33,000
How to get the same key for both sender and receiver?

128
00:16:29,000 --> 00:16:33,000
如何为发送者和接收者获取相同的密钥？

129
00:16:33,000 --> 00:16:37,000
We said this is a key distribution problem, right?

129
00:16:33,000 --> 00:16:37,000
我们说这确实是一个密钥分发问题，您同意吗？

130
00:16:37,000 --> 00:16:40,000
So in fact, it is difficult.

130
00:16:37,000 --> 00:16:40,000
事实上，做这件事挺难的。

131
00:16:40,000 --> 00:16:51,000
Well, in the public key scheme, we can use Diffie-Hellman, DH, this algorithm to provide the key distribution.

131
00:16:40,000 --> 00:16:51,000
好的，在公钥加密方案中，我们可以使用 Diffie-Hellman 算法，即 DH 算法，来实现密钥的分配。

132
00:16:51,000 --> 00:16:59,000
Both sides, they can, after some calculation, they can get the same key for the encryption and decryption.

132
00:16:51,000 --> 00:16:59,000
双方经过计算后，可以得到相同的加密和解密密钥。这样的表述更为自然易懂。

133
00:16:59,000 --> 00:17:09,000
So key distribution means how to have secure communications in general without having to trust.

133
00:16:59,000 --> 00:17:09,000
密钥分发指的是如何在无需信任的情况下实现一般性的安全通信。

134
00:17:09,000 --> 00:17:22,000
So this is a key, the key distribution center with your key, without a trusted third party.

134
00:17:09,000 --> 00:17:22,000
这是一把钥匙，钥匙分配中心保管着您的钥匙，无需依赖第三方。

135
00:17:22,000 --> 00:17:25,000
The second problem is called the digital signature.

135
00:17:22,000 --> 00:17:25,000
第二个问题叫做数字签名。

136
00:17:25,000 --> 00:17:32,000
So this means how to verify that a message comes intact from the claimed sender.

136
00:17:25,000 --> 00:17:32,000
这意味着如何验证一条消息是否完整无缺地来自声称的发送者。

137
00:17:32,000 --> 00:17:44,000
Well, in the public key scheme, we can use the private key of sender to do the encryption to generate the signature.

137
00:17:32,000 --> 00:17:44,000
好的，在公钥加密方案中，我们可以使用发送者的私钥进行加密操作，从而生成签名。

138
00:17:45,000 --> 00:17:59,000
So we can use private key D of the sender to generate signature.

138
00:17:45,000 --> 00:17:59,000
我们可以使用发送者的私钥 D 来生成签名，这样更自然易懂。

139
00:17:59,000 --> 00:18:02,000
OK.

139
00:17:59,000 --> 00:18:02,000
好的。

140
00:18:02,000 --> 00:18:18,000
So the withfield Diffie and Martin Hellman from Stanford University achieved a breakthrough in 1976 by coming up with a method that addressed the key distribution problem.

140
00:18:02,000 --> 00:18:18,000
因此，1976 年，斯坦福大学的惠特菲尔德·迪菲和马丁·赫尔曼提出了一种方法，成功解决了密钥分发难题，实现了重大突破。

141
00:18:18,000 --> 00:18:34,000
So this DH algorithm will allow Alice and Bob to generate the same TK to be used in the symmetric encryption scheme.

141
00:18:18,000 --> 00:18:34,000
因此，这个 DH 算法将允许 Alice 和 Bob 生成相同的密钥 TK，用于对称加密方案，翻译更加自然和易懂。

142
00:18:34,000 --> 00:18:41,000
And RSA algorithm can be used for both purposes.

142
00:18:34,000 --> 00:18:41,000
RSA 算法可以用于这两个目的。

143
00:18:41,000 --> 00:18:49,000
Because RSA algorithm, the original message M can be used as the key.

143
00:18:41,000 --> 00:18:49,000
因为 RSA 算法，原始信息 M 可以用来作为密钥。这样的表述更加自然和易于理解。

144
00:18:49,000 --> 00:18:55,000
M can be used as a key.

144
00:18:49,000 --> 00:18:55,000
M 可以作为键使用。

145
00:18:56,000 --> 00:19:04,000
So this M can be generated by sender and will be decrypted, received by the receiver secretly.

145
00:18:56,000 --> 00:19:04,000
因此，这个 M 可以由发送者生成，接收者将秘密解密并接收。

146
00:19:04,000 --> 00:19:09,000
So this key, this M can be regarded to be the key.

146
00:19:04,000 --> 00:19:09,000
因此，这个 M 可以看作是这把钥匙。

147
00:19:09,000 --> 00:19:27,000
And also in previous slide, well, in the second case, in case B, well, the sender like Bob can use his private key to generate the signature.

147
00:19:09,000 --> 00:19:27,000
在上一张幻灯片中也是如此，嗯，在第二种情况，即情况 B 中，嗯，发送者鲍勃可以使用他的私钥来生成签名。这样的表述更加自然易懂。

148
00:19:27,000 --> 00:19:36,000
So this is a way to generate a signature to be verified by the receiver Alice.

148
00:19:27,000 --> 00:19:36,000
这是一种生成由接收者 Alice 验证的签名的方法。这种方法可以更直观地理解。

149
00:19:36,000 --> 00:19:42,000
OK, we have talked about this one previously for the public key cryptosystem.

149
00:19:36,000 --> 00:19:42,000
好的，我们之前已经就这个公钥密码系统进行过讨论了。

150
00:19:42,000 --> 00:20:02,000
If the sender use the public key of the receiver, like this is A, this is B, A can use B's public key to do the encryption.

150
00:19:42,000 --> 00:20:02,000
如果发送者使用接收者的公钥，例如这是 A，这是 B，A 就可以用 B 的公钥进行加密。这样的表述更加自然易懂。

151
00:20:02,000 --> 00:20:10,000
And send the self-text Y, then only the receiver B can do the decryption.

151
00:20:02,000 --> 00:20:10,000
然后发送自文本 Y，只有接收者 B 才能进行解密。翻译更加自然流畅。

152
00:20:10,000 --> 00:20:17,000
So in this way, we'll guarantee that the secrecy, this property is achieved.

152
00:20:10,000 --> 00:20:17,000
因此，我们将确保实现保密性，这一特性得以保证。

153
00:20:17,000 --> 00:20:24,000
But even this self-text can be obtained by some cryptoanalyst.

153
00:20:17,000 --> 00:20:24,000
即使这种自文本也能被某些密码分析师获得，但翻译起来略显生硬，以下是对其进行润色后的版本：即便这种自述文本也能被某些密码分析师解读出来。

154
00:20:24,000 --> 00:20:35,000
Well, the attacker in the middle, the attacker cannot guess, cannot calculate the private key.

154
00:20:24,000 --> 00:20:35,000
好吧，位于中间的攻击者无法猜测，也无法计算出私钥。这样的表述更为自然易懂。

155
00:20:35,000 --> 00:20:45,000
And not the attacker cannot decrypt the message, cannot get the original message X.

155
00:20:35,000 --> 00:20:45,000
攻击者无法解密信息，无法获取原始信息 X。

156
00:20:45,000 --> 00:20:56,000
So only B with his private key can do the decryption to get the original message X.

156
00:20:45,000 --> 00:20:56,000
只有 B 使用他的私钥才能解密，从而获取原始消息 X。

157
00:20:56,000 --> 00:21:10,000
Well, the second method is to apply the sender's private key to generate, somehow to generate a signature.

157
00:20:56,000 --> 00:21:10,000
嗯，第二种方法是使用发送者的私钥来生成签名，这样生成签名。

158
00:21:10,000 --> 00:21:24,000
So this signature will be verified by receiver B because B will use A's public key to do verification.

158
00:21:10,000 --> 00:21:24,000
因此，这个签名将由接收者 B 进行验证，B 将使用 A 的公钥来进行验证。这样的表述更加自然易懂。

159
00:21:24,000 --> 00:21:35,000
The public key of A to decrypt the message and to verify that the message is really from X, from A.

159
00:21:24,000 --> 00:21:35,000
A 的公钥用于解密消息，并确保消息确实由 X 发出，来自 A。

160
00:21:35,000 --> 00:21:40,000
And we call this the process for authentication.

160
00:21:35,000 --> 00:21:40,000
我们把这个过程称为认证流程。

161
00:21:40,000 --> 00:21:56,000
So authentication means the message is really from someone like from A, right from Alice.

161
00:21:40,000 --> 00:21:56,000
所以说，认证的意思是消息确实来自像 A，也就是 Alice 这样的人。

162
00:21:56,000 --> 00:22:03,000
Well, for receiver, I will use Alice's public key to do the verification.

162
00:21:56,000 --> 00:22:03,000
嗯，对于接收者，我会使用 Alice 的公钥来进行验证。这样表达更自然、易懂。

163
00:22:03,000 --> 00:22:08,000
So that means the message must be sent from Alice.

163
00:22:03,000 --> 00:22:08,000
意思是，这条消息必须由 Alice 发出。

164
00:22:08,000 --> 00:22:14,000
Only Alice has her private key.

164
00:22:08,000 --> 00:22:14,000
只有爱丽丝才有她的私钥。

165
00:22:14,000 --> 00:22:19,000
Of course, you can use both, but you can combine them together.

165
00:22:14,000 --> 00:22:19,000
当然可以同时使用这两个，也可以将它们合并使用，这样更方便。

166
00:22:19,000 --> 00:22:28,000
Well, first, you can use your private key, A's private key, to do the encryption.

166
00:22:19,000 --> 00:22:28,000
好的，首先，您可以使用自己的私钥或 A 的私钥进行加密操作。

167
00:22:29,000 --> 00:22:35,000
That means somehow you can regard this one to be, you generate the signature.

167
00:22:29,000 --> 00:22:35,000
这意味着你可以在某种程度上将其视为，你生成签名。这样表达更为自然和易懂。

168
00:22:35,000 --> 00:22:42,000
Then you use the receiver's public key to do the encryption again.

168
00:22:35,000 --> 00:22:42,000
您再次使用接收者的公钥进行加密，使翻译更加自然易懂。

169
00:22:42,000 --> 00:22:57,000
So this one will, to guarantee the secrecy, the message cannot be decrypted by anyone else, cannot be disclosed, be known by any others.

169
00:22:42,000 --> 00:22:57,000
为了确保保密性，这条信息不能被他人解密，不得泄露，不得让他人得知。

170
00:22:57,000 --> 00:23:15,000
So at the destination part, the receiver can use corresponding decryption algorithm to get back the original message X.

170
00:22:57,000 --> 00:23:15,000
在目的地部分，接收者可以使用相应的解密算法将原始消息 X 还原。

171
00:23:15,000 --> 00:23:24,000
When we apply the public key system, the public key scheme, we can achieve the following three functions.

171
00:23:15,000 --> 00:23:24,000
当我们采用公钥系统及公钥方案时，可以达成以下三个功能。

172
00:23:24,000 --> 00:23:27,000
The first one is for encryption and decryption.

172
00:23:24,000 --> 00:23:27,000
第一个用于加密和解密。

173
00:23:27,000 --> 00:23:35,000
So that means the sender can encrypt a message with a recipient's public key, right?

173
00:23:27,000 --> 00:23:35,000
这意味着发件人可以用接收者的公钥加密信息，对吗？

174
00:23:35,000 --> 00:23:42,000
So that means the generated message Y can be transmitted in a public channel.

174
00:23:35,000 --> 00:23:42,000
这意味着生成的消息 Y 可以在公共渠道中传输。

175
00:23:42,000 --> 00:23:59,000
So this Y equals original message, or we call it to be C subtext, equals N to the E mod N.

175
00:23:42,000 --> 00:23:59,000
因此，这个 Y 代表原始信息，或称为 C 子文本，等于 N 的 E 模 N。

176
00:23:59,000 --> 00:24:03,000
So this is the encryption process.

176
00:23:59,000 --> 00:24:03,000
这就是加密过程，简单来说。

177
00:24:03,000 --> 00:24:10,000
We get the subtext and only the receiver with a private key can do the decryption.

177
00:24:03,000 --> 00:24:10,000
我们获取到的是隐含信息，只有持有私钥的接收者才能进行解密。这句话经过润色，使其在简体中文中更加自然易懂。

178
00:24:10,000 --> 00:24:13,000
So this is the encryption, decryption.

178
00:24:10,000 --> 00:24:13,000
这就是加密和解密的过程。

179
00:24:13,000 --> 00:24:19,000
Or the sender can sign a message with its private key.

179
00:24:13,000 --> 00:24:19,000
发件人可以用自己的私钥对消息进行签名。这样的表述更符合中文的表达习惯。

180
00:24:19,000 --> 00:24:29,000
We say this signature will be generated by M to the D mod N.

180
00:24:19,000 --> 00:24:29,000
我们说这个签名将由 M 模 N 的 D 次幂生成。

181
00:24:29,000 --> 00:24:41,000
Okay, you generate your signature and signature can be verified by receiver using your public key.

181
00:24:29,000 --> 00:24:41,000
好的，您生成您的签名，接收者可以使用您的公钥进行验证。

182
00:24:41,000 --> 00:24:48,000
Of course, we can use the public key scheme to do the key exchange.

182
00:24:41,000 --> 00:24:48,000
当然可以，我们可以采用公钥方案进行密钥交换，这样更自然易懂。

183
00:24:48,000 --> 00:24:55,000
Just like two sides can cooperate to exchange a session key, KAB, right?

183
00:24:48,000 --> 00:24:55,000
就像两个部分可以合作交换一个会话密钥，KAB，对吗？

184
00:24:55,000 --> 00:24:59,000
KAB in the Diffie-Hellman algorithm.

184
00:24:55,000 --> 00:24:59,000
在 Diffie-Hellman 算法中，存在 KAB。

185
00:24:59,000 --> 00:25:12,000
So both sides will get a key KAB equals G AB mod P, okay?

185
00:24:59,000 --> 00:25:12,000
因此，双方都会得到一个密钥 KAB，等于 GAB 模 P，可以吗？

186
00:25:12,000 --> 00:25:17,000
So Alice and Bob can locally choose the private data A and B.

186
00:25:12,000 --> 00:25:17,000
因此，Alice 和 Bob 可以在本地选择私有数据 A 和 B。这样表达更为自然和易懂。

187
00:25:17,000 --> 00:25:25,000
After some data exchange, they will locally get the same key KAB.

187
00:25:17,000 --> 00:25:25,000
经过数据交换后，他们本地将获得相同的密钥 KAB。

188
00:25:25,000 --> 00:25:35,000
This key KAB can be used for future message encryption in the symmetric encryption algorithm.

188
00:25:25,000 --> 00:25:35,000
此密钥 KAB 可用于未来消息在对称加密算法中的加密。

189
00:25:35,000 --> 00:25:40,000
Some public key algorithms are suitable for all three applications.

189
00:25:35,000 --> 00:25:40,000
一些公钥算法适用于所有三种应用，表述更为自然易懂。

190
00:25:40,000 --> 00:25:46,000
Some can be used for only one or two.

190
00:25:40,000 --> 00:25:46,000
有些物品只能使用一次或两次，表达更为自然。

191
00:25:46,000 --> 00:25:49,000
So RSA can be used for all three, right?

191
00:25:46,000 --> 00:25:49,000
所以 RSA 可以用于这三个用途，对吗？

192
00:25:49,000 --> 00:25:53,000
Encryption, decryption, digital signature.

192
00:25:49,000 --> 00:25:53,000
加密、解密和数字签名。

193
00:25:53,000 --> 00:25:57,000
So this is like a message to the E.

193
00:25:53,000 --> 00:25:57,000
这就像是对 E 发的一条信息。

194
00:25:57,000 --> 00:26:05,000
Digital signature can be generated by message to the D and key exchange.

194
00:25:57,000 --> 00:26:05,000
数字签名可以通过向 D 发送消息并交换密钥来生成。

195
00:26:05,000 --> 00:26:17,000
Key exchange means will the M to C to M, this M can be regarded as a key, okay?

195
00:26:05,000 --> 00:26:17,000
密钥交换是指 M 到 C 再到 M 的过程，这里的 M 可以被视为一个密钥，好吗？

196
00:26:17,000 --> 00:26:25,000
So both sender, receiver, they know the M to be the key to be used by both sides.

196
00:26:17,000 --> 00:26:25,000
因此，发送方和接收方都知道 M 是双方需要使用的密钥。

197
00:26:25,000 --> 00:26:34,000
Elliptic curve, similarly, well, this one requires some mathematical background.

197
00:26:25,000 --> 00:26:34,000
椭圆曲线，嗯，这个需要一定的数学知识背景。

198
00:26:34,000 --> 00:26:38,000
Well, so we don't talk about it.

198
00:26:34,000 --> 00:26:38,000
好吧，我们就不提那件事了。

199
00:26:38,000 --> 00:26:45,000
Elliptic curve is more efficient compared to the RSA.

199
00:26:38,000 --> 00:26:45,000
椭圆曲线相对于 RSA 来说更加高效。

200
00:26:45,000 --> 00:26:52,000
More efficient.

200
00:26:45,000 --> 00:26:52,000
更高效（更自然、更易理解的表达）。

201
00:26:52,000 --> 00:26:58,000
Now RSA, so they can achieve all three functions.

201
00:26:52,000 --> 00:26:58,000
现在有了 RSA，他们能够实现所有三个功能。

202
00:26:58,000 --> 00:27:05,000
Elliptic curve, this kind of public key scheme.

202
00:26:58,000 --> 00:27:05,000
椭圆曲线，这是一种公钥方案。

203
00:27:05,000 --> 00:27:12,000
The Diffie-Hellman is used only for DH, is only used for key exchange.

203
00:27:05,000 --> 00:27:12,000
Diffie-Hellman 算法仅用于密钥交换，仅此一项功能。

204
00:27:12,000 --> 00:27:17,000
And DSS is digital signature standard.

204
00:27:12,000 --> 00:27:17,000
DSS 是数字签名标准，这是一个数字签名标准。

205
00:27:17,000 --> 00:27:27,000
So this one is proposed by the United States.

205
00:27:17,000 --> 00:27:27,000
这个是由美国提出的，表述更为自然。

206
00:27:27,000 --> 00:27:34,000
This one is used only for digital signature generation and verification.

206
00:27:27,000 --> 00:27:34,000
这个仅用于数字签名的生成与验证。

207
00:27:34,000 --> 00:27:47,000
So this is a digital signature standard.

207
00:27:34,000 --> 00:27:47,000
这是一种数字签名标准。

208
00:27:47,000 --> 00:27:53,000
For the public key, this kind of scheme, it has some requirements.

208
00:27:47,000 --> 00:27:53,000
对于公钥，这种方案有一些具体要求。

209
00:27:53,000 --> 00:27:59,000
The public key algorithms must fulfill the following three requirements.

209
00:27:53,000 --> 00:27:59,000
公钥算法必须满足以下三个基本要求。

210
00:27:59,000 --> 00:28:09,000
The first requirement means that, well, it is computationally easy for party B to generate a pair of keys, right?

210
00:27:59,000 --> 00:28:09,000
第一个要求的意思是，乙方生成一对密钥在计算上很简单，对吧？

211
00:28:09,000 --> 00:28:14,000
To generate the key is not difficult.

211
00:28:09,000 --> 00:28:14,000
生成密钥其实并不难。

212
00:28:14,000 --> 00:28:22,000
So public key, like in RSA algorithm, where public key

212
00:28:14,000 --> 00:28:22,000
如 RSA 算法中的公钥，这里的公钥是指

213
00:28:22,000 --> 00:28:35,000
E and N, so we know the process, right? Once we know N equals P times Q, then we know phi N.

213
00:28:22,000 --> 00:28:35,000
E 和 N，所以我们知道这个过程，对吧？一旦我们知道 N 等于 P 乘以 Q，那么我们就知道φN。这个翻译更加自然和易懂。

214
00:28:35,000 --> 00:28:44,000
So from phi N we choose E, then we are able to calculate D easily.

214
00:28:35,000 --> 00:28:44,000
因此，从 phi N 中选取 E，这样我们就能轻松计算出 D。

215
00:28:44,000 --> 00:28:48,000
So D is a private key.

215
00:28:44,000 --> 00:28:48,000
因此，D 是一个私钥。

216
00:28:48,000 --> 00:28:56,000
So this process is not difficult. So once you have very large P and Q, two prime numbers,

216
00:28:48,000 --> 00:28:56,000
这个过程并不复杂。所以一旦你拥有了非常大的质数 P 和 Q，那么...

217
00:28:56,000 --> 00:29:04,000
then you can follow this process to generate the public key and the private key.

217
00:28:56,000 --> 00:29:04,000
您可以按照以下步骤生成公钥和私钥（优化版）：

218
00:29:04,000 --> 00:29:15,000
It is also computationally easy for sender A knowing the public key and the message to be encrypted to generate the corresponding subtext.

218
00:29:04,000 --> 00:29:15,000
发送者 A 只要知道公钥和待加密的消息，生成相应的子文本在计算上就非常简单。

219
00:29:15,000 --> 00:29:23,000
So C equals M to the E mod N. This is not that difficult.

219
00:29:15,000 --> 00:29:23,000
因此，C 等于 M 的 E 次方对 N 取模。这并不复杂。

220
00:29:23,000 --> 00:29:31,000
And also for the receiver B to do the decryption, this process is not difficult.

220
00:29:23,000 --> 00:29:31,000
为了接收者 B 解密，这个过程并不复杂。

221
00:29:31,000 --> 00:29:43,000
So that means to calculate M equals C to the D mod N, well, this is computationally achievable.

221
00:29:31,000 --> 00:29:43,000
这意味着计算 M 等于 C 的 D 模 N，嗯，这在计算上是可行的。

222
00:29:43,000 --> 00:29:59,000
However, it is computationally infeasible that for an adversary knowing the public key from E and N to determine the private key,

222
00:29:43,000 --> 00:29:59,000
然而，敌手仅凭 E 和 N 的公钥无法计算出私钥，这在计算上是不切实际的，翻译如下：然而，仅凭 E 和 N 的公钥无法计算出私钥，这在计算上是不切实际的

223
00:29:59,000 --> 00:30:06,000
this is infeasible.

223
00:29:59,000 --> 00:30:06,000
这根本行不通。

224
00:30:06,000 --> 00:30:17,000
Well, the only way is to derive the private key is you should guess N equals the product of P and Q.

224
00:30:06,000 --> 00:30:17,000
好吧，获取私钥的唯一途径是猜测 N 等于 P 和 Q 的乘积。

225
00:30:17,000 --> 00:30:24,000
How to get this P and Q? Well, this is infeasible at this moment.

225
00:30:17,000 --> 00:30:24,000
如何得到这个 P 和 Q 呢？目前还无法实现。

226
00:30:24,000 --> 00:30:34,000
So we can choose P and Q to be very large.

226
00:30:24,000 --> 00:30:34,000
因此，我们可以选择 P 和 Q 的值非常大。这样表达更自然、易懂。

227
00:30:34,000 --> 00:30:48,000
And also for an adversary, it is computationally infeasible from public key and subtext

227
00:30:34,000 --> 00:30:48,000
对于对手而言，从公钥和暗文中进行计算是不可行的

228
00:30:48,000 --> 00:30:52,000
to recover the original message M.

228
00:30:48,000 --> 00:30:52,000
恢复原始消息 M（更自然、更易理解的翻译）

229
00:30:52,000 --> 00:31:11,000
Because original message M equals C to the D mod N. Without this D, you cannot derive the original message M.

229
00:30:52,000 --> 00:31:11,000
因为原始消息 M 等于 C 模 N。没有这个 D，就无法推导出原始消息 M。

230
00:31:11,000 --> 00:31:19,000
Without D, you cannot get the original message M.

230
00:31:11,000 --> 00:31:19,000
没有 D，就无法获取原始消息 M。

231
00:31:19,000 --> 00:31:25,000
Well, in the public key scheme, the two keys can be applied in other order.

231
00:31:19,000 --> 00:31:25,000
好的，在公钥体系中，这两个密钥可以按照不同的顺序使用。

232
00:31:25,000 --> 00:31:36,000
Well, we can do the encryption like M to the D mod N or M to the C mod N.

232
00:31:25,000 --> 00:31:36,000
好的，我们可以像 M 模 N 的 D 次方或 C 次方那样进行加密。这样的表述更符合中文的表达习惯。

233
00:31:36,000 --> 00:31:49,000
So the second line means we want to achieve secrecy, confidentiality.

233
00:31:36,000 --> 00:31:49,000
因此，第二行表示我们希望实现保密和机密性。

234
00:31:49,000 --> 00:32:02,000
Secrecy. The first line means we want to achieve the signature authentication.

234
00:31:49,000 --> 00:32:02,000
保密性。第一行表示我们希望实现签名认证功能。

235
00:32:02,000 --> 00:32:07,000
Use your private key where you can generate your signature.

235
00:32:02,000 --> 00:32:07,000
在您能够生成签名的地方使用您的私钥。

236
00:32:07,000 --> 00:32:21,000
Use your public key where you can conceal your message M.

236
00:32:07,000 --> 00:32:21,000
在您能够隐藏消息 M 的地方，请使用您的公钥。

237
00:32:21,000 --> 00:32:29,000
So in this design, in this RSA algorithm, we call it.

237
00:32:21,000 --> 00:32:29,000
在这个设计方案中，我们将其称为 RSA 算法。

238
00:32:29,000 --> 00:32:43,000
So in this RSA algorithm, in the encryption-decryption process, we say, well, in fact, it provides some trapped one-way function.

238
00:32:29,000 --> 00:32:43,000
在这个 RSA 算法中，加密解密过程中，实际上提供了一些具有陷门特性的单向函数。

239
00:32:43,000 --> 00:32:47,000
First, we look at the meaning of one-way function.

239
00:32:43,000 --> 00:32:47,000
首先，我们来探讨一下单射函数的含义。

240
00:32:47,000 --> 00:32:59,000
So a one-way function means this function maps a domain into a range.

240
00:32:47,000 --> 00:32:59,000
因此，单射函数是指这样一个函数，它将一个域映射到一个值域。

241
00:32:59,000 --> 00:33:07,000
So from domain X, capital X, to a range Y. So that means it defines a mapping.

241
00:32:59,000 --> 00:33:07,000
从域名 X，首字母大写的 X，到范围 Y。这表示它定义了一个映射关系。

242
00:33:07,000 --> 00:33:13,000
A mapping from X to Y.

242
00:33:07,000 --> 00:33:13,000
X 到 Y 的映射。

243
00:33:13,000 --> 00:33:18,000
This is a function. A mapping from X to Y.

243
00:33:13,000 --> 00:33:18,000
这是一个函数。X 到 Y 的映射关系。

244
00:33:18,000 --> 00:33:28,000
So this function, given an input, given an input X belong to X.

244
00:33:18,000 --> 00:33:28,000
因此，这个函数接受一个输入，即输入 X 属于 X。

245
00:33:28,000 --> 00:33:36,000
So FX equals some Y. And this small y belong to the range.

245
00:33:28,000 --> 00:33:36,000
因此，FX 等于某个 Y。这个小 y 位于该范围内。

246
00:33:36,000 --> 00:33:45,000
From an X, we have a unique Y.

246
00:33:36,000 --> 00:33:45,000
从 X 出发，我们拥有一个独特的 Y。

247
00:33:45,000 --> 00:33:55,000
So this one-way means, well, from X to Y, it is this direction. It is easy.

247
00:33:45,000 --> 00:33:55,000
这意味着，从 X 到 Y 的方向，很简单。

248
00:33:55,000 --> 00:34:04,000
From X, given the input, we follow the function calculation. We get a Y. It is easy.

248
00:33:55,000 --> 00:34:04,000
从 X 出发，根据输入，我们遵循函数计算过程。得到一个 Y。这很简单。

249
00:34:04,000 --> 00:34:09,000
However, the inverse way is impossible.

249
00:34:04,000 --> 00:34:09,000
然而，反过来是不行的。

250
00:34:09,000 --> 00:34:20,000
So from Y to get the original X, this is infeasible. Not possible.

250
00:34:09,000 --> 00:34:20,000
因此，从 Y 到获取原始 X 是不可行的，这是不可能实现的。

251
00:34:20,000 --> 00:34:27,000
So we can see for the hash function, like the MD5, the SHA256.

251
00:34:20,000 --> 00:34:27,000
我们可以看到，例如 MD5、SHA256 这样的哈希函数。

252
00:34:27,000 --> 00:34:43,000
From the input X to the SHA256, with input X, we get its output, H.

252
00:34:27,000 --> 00:34:43,000
从输入 X 到 SHA256 算法，输入 X 得到其输出 H。

253
00:34:43,000 --> 00:34:55,000
This is easy. However, from H, if we want to guess what's the original input X, this is not possible.

253
00:34:43,000 --> 00:34:55,000
这很简单。但是，从 H 开始，想要猜测原始输入 X 是什么，就无从下手了。

254
00:34:55,000 --> 00:35:00,000
Well, based on the one-way function, we have the trapdoor one-way function.

254
00:34:55,000 --> 00:35:00,000
基于单射函数，我们得到了具有陷阱门的单射函数。这个描述经过调整，使其在简体中文中更加自然易懂。

255
00:35:00,000 --> 00:35:06,000
The trapdoor one-way function is a family of invertible function FK.

255
00:35:00,000 --> 00:35:06,000
单向门函数族是一组可逆函数 FK，翻译得更加自然和易于理解。

256
00:35:06,000 --> 00:35:17,000
Such that, well, with a K and with X input, we calculate the Y. It is easy.

256
00:35:06,000 --> 00:35:17,000
嗯，输入 K 和 X，我们计算 Y，这很简单。

257
00:35:17,000 --> 00:35:31,000
And also, with Y and the K, we get its inverse, reverse way. In the reverse way, we get original X. It is also easy.

257
00:35:17,000 --> 00:35:31,000
“而且，加上 Y 和 K，我们得到它的逆，即反向方式。在反向方式中，我们就能得到原始的 X。这也很简单。”

258
00:35:31,000 --> 00:35:40,000
However, if we don't know the K, well, to calculate the original input X, it is infeasible.

258
00:35:31,000 --> 00:35:40,000
然而，若不知 K 值，计算原始输入 X 便无法进行。

259
00:35:40,000 --> 00:35:57,000
So that means just like in our RSA algorithm, we have from, well, with the original message M,

259
00:35:40,000 --> 00:35:57,000
这意味着正如我们在 RSA 算法中所做的那样，我们从原始消息 M 出发，

260
00:35:57,000 --> 00:36:14,000
and we use the public key E, we use public key E, we mod N, we get the C. So this is easy.

260
00:35:57,000 --> 00:36:14,000
我们使用公钥 E，对 N 取模得到 C，这个过程很简单。

261
00:36:14,000 --> 00:36:26,000
We see C is Y, right? And once we have the D, we mod N, we get M. This is easy.

261
00:36:14,000 --> 00:36:26,000
我们看到 C 对应 Y，对吧？一旦我们得到 D，对 N 取模后，就得到 M。这很简单。

262
00:36:26,000 --> 00:36:42,000
However, without D, we send N to get M and no D, this is impossible.

262
00:36:26,000 --> 00:36:42,000
然而，如果没有 D，我们发送 N 去获取 M，那就无法实现。

263
00:36:42,000 --> 00:36:57,000
That means the D is a key K here. No D to get back the original message M, this is infeasible.

263
00:36:42,000 --> 00:36:57,000
这意味着 D 是这里的密钥 K。没有 D 就无法恢复原始消息 M，这是行不通的。

264
00:36:57,000 --> 00:37:06,000
So that means a practical public key scheme depends on a suitable trapdoor one-way function.

264
00:36:57,000 --> 00:37:06,000
这意味着一个实用的公钥方案依赖于一个合适的门限单向函数，这样的表述更为自然易懂。

265
00:37:06,000 --> 00:37:21,000
We should have the public key to do the decryption such that we can get the original message M from the self-text C.

265
00:37:06,000 --> 00:37:21,000
我们需要拥有公钥以执行解密操作，从而从自文本 C 中提取原始消息 M。

266
00:37:21,000 --> 00:37:33,000
Okay, we can see for the RSA algorithm, before the application of the public key crypto system, each participant must generate a pair of keys.

266
00:37:21,000 --> 00:37:33,000
好的，在应用公钥加密系统之前，我们可以看到，每个参与者都需要生成一对密钥。

267
00:37:33,000 --> 00:37:46,000
This pair of keys is E and D, right? E is a public key, D is a corresponding private key.

267
00:37:33,000 --> 00:37:46,000
这对密钥是 E 和 D，对吧？E 是公钥，D 是相应的私钥。

268
00:37:46,000 --> 00:37:56,000
To generate E and D, first we should choose two prime numbers, P and Q, secretly.

268
00:37:46,000 --> 00:37:56,000
首先应秘密选择两个质数 P 和 Q，以生成 E 和 D。

269
00:37:56,000 --> 00:38:08,000
You cannot disclose these two big numbers, otherwise people will generate your private key easily.

269
00:37:56,000 --> 00:38:08,000
您不能泄露这两个重要数字，否则别人很容易就能推导出您的私钥。

270
00:38:08,000 --> 00:38:21,000
So once you choose P and Q, normally you will select E and then you will calculate D as your private key.

270
00:38:08,000 --> 00:38:21,000
因此，选择 P 和 Q 后，通常会选择 E，然后计算 D 作为您的私钥。

271
00:38:21,000 --> 00:38:32,000
So because the value N equals P times Q will be, this N will be known to any potential adversary.

271
00:38:21,000 --> 00:38:32,000
因此，由于 N 的值等于 P 乘以 Q，任何可能的对手都会知道这个 N。

272
00:38:32,000 --> 00:38:45,000
The primes must be chosen from a sufficiently large set. So primes P, Q, you should choose these two to be very large, right?

272
00:38:32,000 --> 00:38:45,000
素数必须从足够大的集合中选择。因此，素数 P 和 Q，您应该选择这两个数非常大，没错吧？

273
00:38:51,000 --> 00:39:03,000
Okay, the method used for finding large primes, well, this method should be reasonably efficient.

273
00:38:51,000 --> 00:39:03,000
好吧，寻找大质数所用的方法，嗯，这个方法应该效率很高。

274
00:39:03,000 --> 00:39:13,000
To attack the RSA algorithm, we called this problem is a factoring problem.

274
00:39:03,000 --> 00:39:13,000
为了攻击 RSA 算法，我们将其称为分解问题，这个问题旨在攻击 RSA 算法。

275
00:39:13,000 --> 00:39:29,000
The reason is because once you can factor N into its two prime factors P and Q, so once you can get N equals P times Q,

275
00:39:13,000 --> 00:39:29,000
原因在于，一旦你能够将 N 分解为它的两个质数因子 P 和 Q，一旦你能够得到 N 等于 P 乘以 Q，

276
00:39:29,000 --> 00:39:39,000
then you will be able to calculate its corresponding potential function phi, right?

276
00:39:29,000 --> 00:39:39,000
你就能计算出其对应的势函数φ了，对吧？

277
00:39:39,000 --> 00:39:52,000
Once you can do that factorization, just like suppose N equals 1, 1, 9, so what's P and Q?

277
00:39:39,000 --> 00:39:52,000
一旦你能完成这个因式分解，假设 N 等于 1、1、9，那么 P 和 Q 分别是多少？

278
00:39:52,000 --> 00:39:55,000
P equals Q equals

278
00:39:52,000 --> 00:39:55,000
P 等于 Q 等于

279
00:40:01,000 --> 00:40:09,000
Okay, 7, 17, right? So then, well, because this number is very small, right?

279
00:40:01,000 --> 00:40:09,000
好的，7，17，对吧？那么，嗯，这个数字实在太小了，对吧？

280
00:40:09,000 --> 00:40:19,000
You can do the factorization quickly and then you'll be able to calculate the phi to be 96, right?

280
00:40:09,000 --> 00:40:19,000
你可以快速进行因式分解，然后就能计算出 phi 为 96，对吧？（更自然、更易理解的翻译）

281
00:40:19,000 --> 00:40:29,000
In our previous example, and then you will be able to suppose E is any number.

281
00:40:19,000 --> 00:40:29,000
在我们之前的例子中，然后你可以假设 E 是任意一个数。

282
00:40:29,000 --> 00:40:39,000
Can E be like, suppose E is 7, right?

282
00:40:29,000 --> 00:40:39,000
假设 E 等于 7，对吗？

283
00:40:39,000 --> 00:40:44,000
Can we choose E to be 10?

283
00:40:39,000 --> 00:40:44,000
我们能否选择 E 为 10？

284
00:40:44,000 --> 00:40:47,000
Not possible, why not?

284
00:40:44,000 --> 00:40:47,000
不可能，为何如此？

285
00:40:53,000 --> 00:40:58,000
Not really prime to phi, right?

285
00:40:53,000 --> 00:40:58,000
真的跟 phi 不太搭，对吧？

286
00:40:58,000 --> 00:41:06,000
So when you guarantee that DCT E and phi should be 1, so this one is not okay.

286
00:40:58,000 --> 00:41:06,000
当你确保 DCT E 和 phi 值应为 1 时，这个就不对了。

287
00:41:06,000 --> 00:41:17,000
Saving is fine. Well, given we know phi N, we know E, we will be able to generate the D.

287
00:41:06,000 --> 00:41:17,000
储蓄没问题。既然已知 phi N，那么 E 也就知道了，我们就能生成 D。

288
00:41:17,000 --> 00:41:23,000
So D equals actually is coming to

288
00:41:17,000 --> 00:41:23,000
实际上，D 正在到来

289
00:41:26,000 --> 00:41:31,000
So D is E must 1 mod phi N.

289
00:41:26,000 --> 00:41:31,000
因此，D 是 E 模φN 等于 1。

290
00:41:31,000 --> 00:41:45,000
To get the modular inverse value, we can use the extended Euclidean algorithm, but we can quickly calculate D from E and phi.

290
00:41:31,000 --> 00:41:45,000
要获取模逆值，我们可以使用扩展欧几里得算法，但我们可以快速从 E 和φ计算出 D，翻译更加自然流畅。

291
00:41:45,000 --> 00:41:55,000
So once we can do the factorization problem, we can solve the factorization of N and E is null.

291
00:41:45,000 --> 00:41:55,000
因此，一旦我们解决了因式分解问题，就能解决 N 的因式分解问题，而 E 为空的情况。

292
00:41:55,000 --> 00:42:01,000
So we will be able to calculate the private key D.

292
00:41:55,000 --> 00:42:01,000
因此，我们将能够计算出私钥 D。

293
00:42:01,000 --> 00:42:10,000
And we can see the history to do this factorization problem, the challenge.

293
00:42:01,000 --> 00:42:10,000
我们可以回顾进行这个因式分解问题的历史，挑战之处。

294
00:42:10,000 --> 00:42:20,000
In December 2000 online, well, we can factor rising the N.

294
00:42:10,000 --> 00:42:20,000
2000 年 12 月在线时，嗯，我们可以考虑提升 N 的值。

295
00:42:20,000 --> 00:42:25,000
So this N is the number of bits.

295
00:42:20,000 --> 00:42:25,000
这里的 N 代表比特数。

296
00:42:25,000 --> 00:42:38,000
To be 768 bits, corresponds to the number of decimal digits to be 232 decimal digits.

296
00:42:25,000 --> 00:42:38,000
要成为 768 位，相当于 232 个十进制数字的位数。

297
00:42:38,000 --> 00:42:42,000
The recent progress is in 2020.

297
00:42:38,000 --> 00:42:42,000
近期进展发生在 2020 年。

298
00:42:42,000 --> 00:42:55,000
Well, a group of people showed that we are able to factorize big N with the 829 bits.

298
00:42:42,000 --> 00:42:55,000
嗯，一群人证明了我们能够将 829 位的 N 大数分解成质因数。这个翻译更加自然和易于理解。

299
00:42:55,000 --> 00:43:03,000
The length for N to be over 800 is not secure anymore.

299
00:42:55,000 --> 00:43:03,000
N 的长度超过 800 不再安全，这样的设置已经不够安全了。

300
00:43:04,000 --> 00:43:16,000
So it is suggested that we should at least choose the N to be 1 or 24 bits today.

300
00:43:04,000 --> 00:43:16,000
今天至少应选择 1 或 24 位的 N

301
00:43:16,000 --> 00:43:26,000
Or to be more secure, to be 2 or 48 bits.

301
00:43:16,000 --> 00:43:26,000
更安全地讲，是 2 位或 48 位。

302
00:43:26,000 --> 00:43:34,000
For your N to generate your public key and private key in your application.

302
00:43:26,000 --> 00:43:34,000
为您的 N 生成您应用程序中的公钥和私钥。

303
00:43:38,000 --> 00:43:44,000
Okay, so let's have an overview about the encryption.

303
00:43:38,000 --> 00:43:44,000
好的，那么我们先来了解一下加密的基本情况。

304
00:43:44,000 --> 00:43:50,000
So we can use either the symmetric encryption.

304
00:43:44,000 --> 00:43:50,000
我们可以采用对称加密方式。

305
00:43:50,000 --> 00:43:56,000
So symmetric encryption means we assume we can achieve confidentiality.

305
00:43:50,000 --> 00:43:56,000
对称加密意味着我们假设能够实现保密性。这样的表述更加自然易懂。

306
00:43:56,000 --> 00:44:03,000
That means the message will be kept to be a secret.

306
00:43:56,000 --> 00:44:03,000
这意味着这条消息将被严格保密。

307
00:44:03,000 --> 00:44:17,000
Will only be known by the sender and the receiver.

307
00:44:03,000 --> 00:44:17,000
只会为发送者和接收者所知。这句话听起来略显生硬，可以调整为：“只有发送者和接收者知晓。”这样更符合中文的表达习惯。

308
00:44:17,000 --> 00:44:22,000
Because both the sender and the receiver, they have the key K.

308
00:44:17,000 --> 00:44:22,000
因为发送者和接收者都拥有密钥 K。

309
00:44:22,000 --> 00:44:36,000
And this key K can be used in both the encryption and the decryption algorithm, like the AES algorithm.

309
00:44:22,000 --> 00:44:36,000
这把密钥 K 可用于加密和解密算法，例如 AES 算法。这样的表述在中文中更为自然和易于理解。

310
00:44:37,000 --> 00:44:47,000
So in this symmetric scheme, we can achieve the message confidentiality.

310
00:44:37,000 --> 00:44:47,000
在这个对称方案中，我们能够实现消息的保密性。

311
00:44:47,000 --> 00:44:49,000
Not known by others.

311
00:44:47,000 --> 00:44:49,000
他人不清楚

312
00:44:49,000 --> 00:44:53,000
So the message cannot be known by others.

312
00:44:49,000 --> 00:44:53,000
因此，别人无法得知这条信息。

313
00:44:53,000 --> 00:44:57,000
If we apply the public key encryption,

313
00:44:53,000 --> 00:44:57,000
如果我们使用公钥加密，

314
00:44:57,000 --> 00:45:06,000
Once we use the public key of the receiver B,

314
00:44:57,000 --> 00:45:06,000
当我们使用接收者 B 的公钥时，

315
00:45:06,000 --> 00:45:12,000
And then we can achieve the message confidentiality.

315
00:45:06,000 --> 00:45:12,000
然后我们就能实现消息的保密性。

316
00:45:12,000 --> 00:45:18,000
The reason is because only the receiver can do the decryption.

316
00:45:12,000 --> 00:45:18,000
原因在于只有接收者才能进行解密操作。

317
00:45:19,000 --> 00:45:28,000
Or we can use AES public key to do the encryption.

317
00:45:19,000 --> 00:45:28,000
我们可以采用 AES 公钥进行加密，这样更自然易懂。

318
00:45:28,000 --> 00:45:35,000
Then we can generate the signature along with the message.

318
00:45:28,000 --> 00:45:35,000
我们可以生成消息和签名，这样更自然易懂。

319
00:45:35,000 --> 00:45:41,000
So this signature will be verified by the receiver B.

319
00:45:35,000 --> 00:45:41,000
因此，这个签名将由接收者 B 进行验证。

320
00:45:41,000 --> 00:45:56,000
So B will use the sender's public key for verification.

320
00:45:41,000 --> 00:45:56,000
B 将使用发送者的公钥进行验证，这样的表述更为自然易懂。

321
00:45:56,000 --> 00:46:13,000
So B as the receiver will guarantee that the message is really from Alice.

321
00:45:56,000 --> 00:46:13,000
因此，作为接收者的 B 将确保消息确实来自 Alice。

322
00:46:13,000 --> 00:46:22,000
Because the B is using Alice's public key to do the decryption.

322
00:46:13,000 --> 00:46:22,000
因为 B 使用 Alice 的公钥进行解密。

323
00:46:22,000 --> 00:46:33,000
Of course, we can use both the private key and public key at both the sender side and the receiver side.

323
00:46:22,000 --> 00:46:33,000
当然，发送方和接收方都可以使用私钥和公钥。这样的表述更自然、易懂。

324
00:46:33,000 --> 00:46:45,000
So private key for signature generation and public key for the message confidentiality.

324
00:46:33,000 --> 00:46:45,000
用于签名生成的私钥，以及用于保障消息保密性的公钥。

325
00:46:45,000 --> 00:46:56,000
To achieve message confidentiality, to guarantee the message is encrypted and not known by others.

325
00:46:45,000 --> 00:46:56,000
为了确保消息的机密性，保证消息加密且不被他人所知。

326
00:46:56,000 --> 00:47:02,000
So in the decryption side, the receiver side, we can do the decryption.

326
00:46:56,000 --> 00:47:02,000
在解密方面，接收方可以进行解密操作。

327
00:47:02,000 --> 00:47:10,000
First use the receiver's private key to do the decryption and then to do the verification.

327
00:47:02,000 --> 00:47:10,000
首先使用接收者的私钥进行解密，然后进行验证。（已优化，使翻译更自然易懂）

328
00:47:10,000 --> 00:47:21,000
So public key of Alice to do the signature verification.

328
00:47:10,000 --> 00:47:21,000
爱丽丝的公钥用于进行签名验证。

329
00:47:21,000 --> 00:47:26,000
Authentication and signature actually should be the same meaning.

329
00:47:21,000 --> 00:47:26,000
认证和签名本应具有相同的意义。

330
00:47:26,000 --> 00:47:33,000
We verify your signature will guarantee this real sender.

330
00:47:26,000 --> 00:47:33,000
我们将验证您的签名，以确保这是真正的发件人。

331
00:47:33,000 --> 00:47:36,000
So we guarantee this real sender.

331
00:47:33,000 --> 00:47:36,000
我们确保这是真正的发件人。

332
00:47:36,000 --> 00:47:41,000
The real sender means this authentication will authorize.

332
00:47:36,000 --> 00:47:41,000
真实发件人表示，这项认证将获得授权。

333
00:47:41,000 --> 00:47:51,000
You're authorized because you can provide a correct signature.

333
00:47:41,000 --> 00:47:51,000
您有权限，因为您能提供正确的签名。（经过优化，使翻译更加自然易懂）

334
00:47:51,000 --> 00:47:58,000
So then we finish our lecture three.

334
00:47:51,000 --> 00:47:58,000
然后我们结束了第三讲的内容。

335
00:47:58,000 --> 00:48:04,000
And we have the TECOM exercises for your practice.

335
00:47:58,000 --> 00:48:04,000
我们为您准备了 TECOM 练习，方便您进行练习。

336
00:48:04,000 --> 00:48:13,000
So exercise four is for RSA and exercise five is for Diffie-Hellman algorithm.

336
00:48:04,000 --> 00:48:13,000
第四题是 RSA 算法，第五题是迪菲-赫尔曼密钥交换算法。

337
00:48:13,000 --> 00:48:18,000
OK, so we finish and let's have a stop, have a break, 10 minutes.

337
00:48:13,000 --> 00:48:18,000
好的，我们结束休息一下，休息 10 分钟。

338
00:48:18,000 --> 00:48:22,000
OK, then after break, we continue with lecture four.

338
00:48:18,000 --> 00:48:22,000
那么，休息一下后，我们继续进行第四讲的学习。

339
00:48:22,000 --> 00:48:23,000
Thank you.

339
00:48:22,000 --> 00:48:23,000
谢谢您。

340
00:48:34,000 --> 00:48:35,000
Thank you.

340
00:48:34,000 --> 00:48:35,000
谢谢您。

341
00:49:04,000 --> 00:49:05,000
Thank you.

341
00:49:04,000 --> 00:49:05,000
谢谢您。

342
00:49:34,000 --> 00:49:36,000
Thank you.

342
00:49:34,000 --> 00:49:36,000
谢谢您。

